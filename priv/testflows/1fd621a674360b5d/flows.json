[{"id":"1fd621a674360b5d","type":"tab","label":"[.docu] function node architecture","disabled":false,"info":"<script>\n$(function(){\n    $('#flowtitle').html($('#flowtitle').text().replace(\"[.docu]\",\"\"));\n})\n</script>\n\n<small><i>[Share](https://flows.red-erik.org/f/1fd621a674360b5d)</i></small>\n\n## Function node Erlang architecture\n\nThe function node is used to execute Erlang code in the context of a message object received by the function node. In combination with the [module](https://flows.red-erik.org/f/442b3bf0d630e21d) node, it can be used to create a complete Erlang application inside of Erlang-Red.\n\nWhen the <a class=\"ahl-node-only\" data-ids=\"7e03f030e5f5a4e7\">inject button</a> is triggered by receiving a [`gen_server:cast(create_outgoing_msg)`](https://github.com/gorenje/erlang-red/blob/16a6e29f75a2154ba56fb0ef69fd2400db676a63/src/routes/ered_http_nodered_inject_node_button_handler.erl#L39-L53) message, the following flowchart of processes is created.\n\n## Flowchart \n\n```mermaid\nflowchart TB\n    3272430156b615cf[\"`ered_node_inject \n      &lt;ered_node&gt;`\"] -- handle_msg/2(outgoing) --> 3142b9a8e864d04f([\"#{Msg}\"])\n    3142b9a8e864d04f -- handle_msg/2(incoming) --> c333a1b8d6ccd24f[\"`ered_node_function \n    &lt;ered_node&gt;`\"]\n    c333a1b8d6ccd24f -- ered_function_code_manager:start/2 --> e9077d2769ed1a86\n    c333a1b8d6ccd24f -. ! perform_func_code .-> e9077d2769ed1a86\n    c333a1b8d6ccd24f -. handle_info/2('DOWN') .-> e9077d2769ed1a86\n    e9077d2769ed1a86 -. handle_event/2('DOWN') .-> c333a1b8d6ccd24f\n    e9077d2769ed1a86 -- elrang:spawn_link/3 --> 3623c7b9447ee093\n    e9077d2769ed1a86 -- erlang:start_timer/3 --> 36fb909a0736d92e\n    3623c7b9447ee093 -. handle_info/2('EXIT') .-> e9077d2769ed1a86 \n    3623c7b9447ee093 -- execute_sync/3 --> cfd2d25f8d7027c4\n    3623c7b9447ee093 -. ! func_completed_with .-> c333a1b8d6ccd24f\n    36fb909a0736d92e -. handle_info/2(timeout) .-> e9077d2769ed1a86\n    cfd2d25f8d7027c4 -- send_message_on_ports/2 --> 1d84888539409a24\n subgraph subGraph0[\"-- for each message --\"]\n        e9077d2769ed1a86[\"`ered_function_code_manager \n        &lt;gen_server&gt;`\"]\n        3623c7b9447ee093[\"`exec func process \n        &lt;erlang&nbsp;process&gt;`\"]\n        cfd2d25f8d7027c4([\"#{Msg2}\"])\n        36fb909a0736d92e[\"`timeout process \n        &lt;erlang&nbsp;process&gt;`\"]\n        1d84888539409a24[\"`ered_node_debug \n        &lt;ered_node&gt;`\"]\n  end\n```\n\nShown are all the communication channels between the moving parts needed to execute the above flow. \n\nNot shown is the interaction with a  [supervisor node](https://github.com/gorenje/erlang-red/blob/16a6e29f75a2154ba56fb0ef69fd2400db676a63/src/nodes/ered_node_erlsupervisor.erl). \n\n## Terminology\n\nIn the flowchart:\n\n- dotted lines are Erlang messages between processes\n- rectangles are processes\n- solid line arrows are function calls\n- the oval `#{Msg}` is just a map containing the Erlang-Red message data\n- the yellow sub-graph is spun-up once per Erlang-Red message\n\nThe <a class=\"ahl-node-only\" data-ids=\"2f618851ebb2f1d9\">function node</a> upon receiving a message spins up the `ered_function_code_manager` to handle the code execution of its function within the context of the Erlang-Red message received.\n\nErlang Messages are not to be confused with Erlang-Red messages. Erlang-Red messages are maps that are passed between nodes, Erlang messages are (mostly) tuples passed between Erlang processes.\n\n## Functionality\n\nNot all processes are started all the time. If the function node as no timeout value (or zero), as is the case for this flow, then the `timeout process` is not started.\n\nAll messages sent from sub-processes to the `ered_function_code_manager` are propagated up to the function node process. Regardless of what type of message the manager receives, it will send a `'DOWN'` message to the function node process. This is because the manager, having sent the message, will shutdown. The node process then decides what to do with failed executions or timeouts or successful executions.\n\nEven though node processes don't and shouldn't die, they do. If the node process does die, then the manager is responsible for cleaning up its processes and also shutting down. When the manager receives a `'DOWN'` message from the function node process, then it will shutdown, killing the `exec func process` with it. The manager receives the `'DOWN'` message from the function node process because it is [monitoring that process](https://github.com/gorenje/erlang-red/blob/16a6e29f75a2154ba56fb0ef69fd2400db676a63/src/managers/ered_function_code_manager.erl#L96-L99) but its not linked since there is a one-to-N relationship: a manager has one function node process but a function node process has *many* managers and if one dies that does not mean the function node process should automatically die - which is the case with linked processes.\n\nThe result of a successful function execution is a new `Msg` object/map which should be passed to the <a class=\"ahl-node-only\" data-ids=\"c964d93feccb251b\">debug node</a>. The debug node is represented by a Erlang process that receives an `handle_event({incoming, Msg})` Erlang message. *Note* this is the original message since that is the message which the function node *originally* received and with which it has now completed with. The newly generated message(s) where never *received* by the function node.\n\nOne thing to note is that the `exec func process` actually sends out the new Erlang-Red message to the nodes connected to the function node. It can do that since `wires` that define those connections have been passed to the exec process from the function node process. This has two benefits: better concurrency and less centralisation of Erlang messages in the function node message queue.\n\nFinally the `exec func process` sends a `gen_server:cast(From, {func_completed_with, Msg})` message to the node function process to inform it that the original `#{Msg}` has been handled successfully. This allows the function node to trigger any [completed nodes](https://flows.red-erik.org/f/0c35d269ca7178c6) listening for completion.\n\n## Node processes do not die - unless ...\n\n... by the loving grace of a supervisor.\n\nThe reason for this architecture is that node processes (i.e. those Erlang processes that represent Erlang-Red nodes) should not die if sub-processes that they start happen to exit abnormally. A node process is responsible for handling incoming messages and updating the flow editor with the nodes status. Therefore it needs to be active all the time.\n\nHowever if a supervisor node is being used to restart the function node on failure, then it has to fail if subprocess fail. The supervisor node uses the [`supervisor`](https://flows.red-erik.org/f/83c5e1824f32abec) behaviour and therefore the function node process is being stopped and started, not the subprocesses started by the function node process.\n\nThis requires management of sub-processes and also consist handling of failures. The function node is a particular challenge since it creates at least one if not two sub-processes for *each* Erlang-Red message it receives. And all those sub-processes have to be shutdown *if* the supervisor shuts down the function node process.\n\nThis can happen if the supervisor has a restart policy of \"one for all\" or \"rest for one\". Both mean that healthy processes are shutdown if a separate unhealthy process dies. This represents a difficult that this architecture aims to solve.\n\n## Code\n\nErlang Code: \n\n- [ered_node_function.erl](https://github.com/gorenje/erlang-red/blob/16a6e29f75a2154ba56fb0ef69fd2400db676a63/src/nodes/ered_node_function.erl)\n- [ered_function_code_manager.erl](https://github.com/gorenje/erlang-red/blob/16a6e29f75a2154ba56fb0ef69fd2400db676a63/src/managers/ered_function_code_manager.erl)\n- [ered_node_inject.erl](https://github.com/gorenje/erlang-red/blob/16a6e29f75a2154ba56fb0ef69fd2400db676a63/src/nodes/ered_node_inject.erl)\n- [ered_node_debug.erl](https://github.com/gorenje/erlang-red/blob/16a6e29f75a2154ba56fb0ef69fd2400db676a63/src/nodes/ered_node_debug.erl)\n- [ered_node](https://github.com/gorenje/erlang-red/blob/16a6e29f75a2154ba56fb0ef69fd2400db676a63/src/ered_node.erl) behaviour\n\n\n","env":[{"name":"ERED_TIMEOUT","value":"1","type":"num"}]},{"id":"7e03f030e5f5a4e7","type":"inject","z":"1fd621a674360b5d","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":513.4285278320312,"y":283.9285583496094,"wires":[["2f618851ebb2f1d9"]]},{"id":"2f618851ebb2f1d9","type":"function","z":"1fd621a674360b5d","name":"function 1","func":"%% Code here is wrapped in a fun (Msg) call\n%% fun (Msg) ->\n    Msg\n%% end.\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":737.4285278320312,"y":283.9285583496094,"wires":[["c964d93feccb251b"]]},{"id":"c964d93feccb251b","type":"debug","z":"1fd621a674360b5d","name":"debug 1","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":954.4285278320312,"y":283.9285583496094,"wires":[]}]