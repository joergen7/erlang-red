[{"id":"bff27e059752cb60","type":"tab","label":"[.breadboard] single connection using state machines","disabled":false,"info":"## Combining tcp in and state machines\n\nHaving thrown together a set of TCP nodes, I wanted to create a telnet server to demonstrate simple interactions with clients. That sort of happened in the [telnet server flow](https://flows.red-erik.org/f/2a95a7b40a798878).\n\nNext step was to create a session management to give the client the feeling that they were unique. I then realised that multiple concurrent connections could be made using the telnet flow.\n\nBecause I wanted to do this step by step, I decided to create a flow that would ensure that only one client is connected at any one time. That makes creating a unique interaction per client simpler - I thought. For the single connection at any one time solution, I wanted to utilise the [state-machine node](https://github.com/gorenje/erlang-red/blob/1a0e15add512d3e2eb892fb70f9d30db30a60be3/src/nodes/ered_node_erlstatemachine.erl).\n\n## How does a state machine work?\n\nErlang has message queues and each message is atomically handled by a process, i.e., there is no concurrent handling of messages by a single process. Regardless of how the message is sent to the process - via cast, call or info. Since Erlang-Red builds on top of that, it also guarantees that messages are handled in order and atomically by *nodes*.\n\nThe <a class=\"ahl-node-only\" data-ids=\"6ed338acd5d4f020\">state machine node</a> uses the `gen_statem` behaviour to model a state-machine based on the module defined in the <a class=\"ahl-node-only\" data-ids=\"2fb1c9e4acd00e7c\">ensure_single_connection module node</a>. The module defines two states: `connected` and `disconnected` and stores the tcp connection session id as single value.\n\n## How does the tcp in node work?\n\n<a class=\"ahl-node-only\" data-ids=\"b42afac9028901f4\">Tcp in node</a> sends out messages per connection per data packet. For string based connections, a message is generated each time the client hits enter. Newline symbol becomes the trigger.\n\nEach client, i.e., connection to the tcp server, is assigned a unique **session id** that is attached to each message generated by that client, i.e., connection.\n\nFinally each message generated by the tcp in node also has a **status** value to indicate whether a connection is new, is sending data or has been closed. Possible [values](https://github.com/gorenje/erlang-red/blob/1a0e15add512d3e2eb892fb70f9d30db30a60be3/src/nodes/ered_node_tcp_in.erl#L106-L114) for the status are `initiated`, `connected` and `closed`.\n\nA typical message from a tcp in node has the format (in Erlang code representing a key-value store):\n\n```erlang\n<<\"_session\">> => #{\n    <<\"type\">>   => <<\"tcp\">>,\n    <<\"id\">>     => SessionId,\n    <<\"status\">> => Status\n},\n<<\"ip\">>      => InterfaceIp,\n<<\"topic\">>   => maps:get(<<\"topic\">>, NodeDef),\n<<\"payload\">> => Payload\n```\n\nThe topic value is assigned to the tcp in node so that all messages, for all clients, have the same topic value but that does not interest us here.\n\n(BTW this message format is conform to Node-REDs tcp in node except for the `_session.status` value, Node-RED does not define a status.)\n\n## State machine and tcp in messages\n\nEach state machine node expects an `action` value and optionally a `payload` value set on the messages it receives. \n\nWhat the <a class=\"ahl-node-only\" data-ids=\"269ef88b6e5dfe87\">change node</a> does is set the `payload` to the session id, i.e. `msg.payload = msg._session.id` and the action to the status, i.e., `msg.action = msg._session.status`.\n\nFor each message the state machine receives, it computes a response of either `ok` or `not_allowed`. Not allowed connections are disconnect by <a class=\"ahl-node-only\" data-ids=\"d6116b5c531ce565\">setting</a> `msg.reset = true` and sending the message to the <a class=\"ahl-node-only\" data-ids=\"ce3d569a01e36814\">tcp out</a> node. \n\n## What happens when tcp out closes a connection?\n\nThe <a class=\"ahl-node-only\" data-ids=\"b42afac9028901f4\">tcp in</a> node generates the `closed` status message for the connection and the state machine can reset its state to `disconnected` - if its the connection being maintained.\n\nThe state machine has two states and a session id. The session id is the identifier for the single connection that is allowed. Once the state machine is disconnected, the session id is reset to `none` but only if the corresponding connection for the session id was closed. \n\nThe next connection will then be set as the new single connection stored by the state machine. Visualising the state transitions:\n\n| state | message status | session ids | new state | outcome |\n| ----- | -------------- | ---------- | --------- | ------- |\n| disconnected | closed | - | disconnected | ok |\n| disconnected | initiated | - | connected | ok |\n| disconnected | connected | - | disconnected | not_allowed|\n| connected | initiated | don't match | connected | not_allowed |\n| connected | initiated | match | connected | ok |\n| connected | connected | match | connected | ok |\n| connected | connected | don't match | connected | not_allowed |\n| connected | closed | match | disconnected | ok |\n| connected | closed | don't match | connected | ok |\n| \\<state> | * | * | \\<state> | not_allowed |\n\n**NOTE**: \n\n- When moving from state `disconnected` to `connected`, the session id of the connection is stored. \n- Also when moving from state `connected` to `disconnected`, the session id is set to `none`. \n- Any unforeseen combinations are `not_allowed` and leads to the connection being closed. \n- All outcomes to closed connections is ok since there is no need to close them again! \n- The outcome `not_allowed` implicitly closes the connection but that may not be the case, the `not_allowed` outcome is an indication of the state machine: *this transition is not allowed*, what the flow does is not for the state machine to decide.\n\n## Why does this work?\n\nThis works because the tcp out node and the tcp in node have a common pool of connections they are administrating. When the tcp out node is sent a reset request, it uses the session ID to retrieve the correct connection. It closes that connection which then triggers a closed message being generated by the tcp in node. The tcp in and tcp out nodes do not communicate directly.\n\nThe state-machine works since it receives one message at a time. And this can cause issues in the <a class=\"ahl-group-only\" data-ids=\"54e4c3fae17a3580\">disconnect connections in parallel</a> flow. What is happening is that a data packet passed out by the tcp in node is cloned and passed to the state-machine and the <a class=\"ahl-group-only\" data-ids=\"8ccba23ce4a6d1ec\">handle communication with a connection</a> flow. This means that *every connection* is sent to the communication flow and can actually communicate with the server.\n\nBut because the <a class=\"ahl-group-only\" data-ids=\"1d162492dd79abb3\">enforce a single connection</a> flow is so \"reliable\" and \"fast\", a connection is closed *before* the user/client can type anything. **BUT** if the state machine fails, then *all* connections are handled by the server. On the other hand, the state machine process runs concurrently to the communication flow, that makes it faster for the client to interact with the server - not having to interact with the state machine for each data packet sent.\n\nHere is a classic trade off between security and performance. I am literally not expecting so much traffic that the state-machine process would not slow down or fail, so for my use case this first attempt is probably fine. \n\nHowever this might not be the case once spammers, crackers, blackhats and other nefarious computer users discover my open port and suddenly everything goes west.\n\n## Serialisation to the rescue\n\nTo fix this, I created the <a class=\"ahl-group-only\" data-ids=\"1029acfc1e365877\">disconnect connections in serial</a> flow that ensures that *every* data packet generated by the tcp in node goes through the state-machine, no questions asked, no quarter given.\n\n*(I literally copied and pasted the first flow and just reconnected two nodes, changed the port to 2525 and added an option to a <a class=\"ahl-node-only\" data-ids=\"a60cbdd34ec7d4fc\">switch node</a> - how simple is that? It literally took me longer to write this sentence!)*\n\nGreat so now I can be certain that all connections are checked *before* they are allowed to communicate with the server. But now I have a different problem ...\n\n## What happens if the state-machine process dies?\n\nErlang being process oriented and every process is, by default, independent of other processes, the parallel flow will actually continue to work if the <a class=\"ahl-node-only\" data-ids=\"6ed338acd5d4f020\">state machine node</a> dies. \n\nThe serial flow will fail. It will stop working as soon as the <a class=\"ahl-node-only\" data-ids=\"a394711dc77a08fb\">state machine node</a> shuts down. The tcp in node might well still be taking connections but these connections will hang since there is no pathway to the <a class=\"ahl-node-only\" data-ids=\"a50b8524d3ad6351\">tcp out</a> node for it to respond to connections.\n\nDamn back to sleepless nights and on-call duty pagers ... or is there another way?\n\n## *All you need is ~~love~~ supervisors*\n\nTo paraphrase [The Beatles](https://en.wikipedia.org/wiki/All_You_Need_Is_Love), all you need is supervisors.\n\nSupervisors are an Erlang mechanism for creating processes that supervise other processes. If children processes go down, then a supervisor can be configured to restart that process or a group of processes. Supervisors can also be assigned limits so that process *aren't* restarted or that infinite restart loops are avoided. \n\nErlang-Red has implemented this mechanism visually using the supervisor node. The <a class=\"ahl-group-only\" data-ids=\"b2459a7ed42bbb57\">disconnect connections in serial & with supervisor</a> flow adds the <a class=\"ahl-node-only\" data-ids=\"9c50a2b367a6eb2b\">supervisor</a> node that supervises <a class=\"ahl-node-only\" data-ids=\"0e5588ba5e03c313\">state-machine node</a>. \n\n*(Again, it was copy, paste, change port number, add supervisor node and deploy the new flow - done. I immediately opened a telnet session and could test the new flow.)*\n\nSupervision should be extended to the tcp nodes and perhaps there are other vital components that also need supervision. But for this writeup, that will do!\n\n## What about using a supervisor with the parallel flow?\n\nAdding a supervisor to the parallel flow would have ensured that a state machine failure could be recovered from however it would not prevent a backlog of messages on the state machine node.\n\nBacklog would result in connections not being closed in a timely fashion. Any backlog of messages in the serial flow would result in bad response times but not in illegal activity.\n\n## Is it possible to supervise the supervisor?\n\n[Yes](https://flows.red-erik.org/f/e447b0048a5983b5). For a better sleep at night, use multiple supervisors supervising supervisors.\n\n","env":[{"name":"ERED_PENDING","type":"bool","value":"true"}]},{"id":"e5c9a8daced2036d","type":"group","z":"bff27e059752cb60","name":"state machine modules","style":{"label":true},"nodes":["2fb1c9e4acd00e7c"],"x":61,"y":54.285715103149414,"w":272,"h":82},{"id":"54e4c3fae17a3580","type":"group","z":"bff27e059752cb60","name":"disconnect connections in parallel","style":{"label":true},"nodes":["ce3d569a01e36814","b42afac9028901f4","1d162492dd79abb3","8ccba23ce4a6d1ec"],"x":63.14272689819336,"y":249.00004959106445,"w":1367.7142143249512,"h":473.6427993774414},{"id":"1029acfc1e365877","type":"group","z":"bff27e059752cb60","name":"disconnect connections in serial","style":{"label":true},"nodes":["a50b8524d3ad6351","dc4a457fb4252964","e17b9ae7a1f0461d","f34d62c6405b4352"],"x":59.2857666015625,"y":778.7143402099609,"w":1646.2857055664062,"h":478.4999008178711},{"id":"b2459a7ed42bbb57","type":"group","z":"bff27e059752cb60","name":"disconnect connections in serial & with supervisor","style":{"label":true},"nodes":["3aade96baaa76948","0a472fabd3d01e82","4f54a8c419e2fb50","deeaf89f0c7b0895"],"x":59.2857666015625,"y":1313.0000267028809,"w":1646.2857055664062,"h":528.2857265472412},{"id":"1d162492dd79abb3","type":"group","z":"bff27e059752cb60","g":"54e4c3fae17a3580","name":"enforce a single connection","style":{"label":true},"nodes":["6ed338acd5d4f020","269ef88b6e5dfe87","64614c1426867215","d6116b5c531ce565"],"x":312.28563690185547,"y":275.00004959106445,"w":953.9999618530273,"h":188.28569793701172},{"id":"8ccba23ce4a6d1ec","type":"group","z":"bff27e059752cb60","g":"54e4c3fae17a3580","name":"handle communication with a connection","style":{"label":true},"nodes":["c0d9ca36b10a7a41","c01f45843fbf19e4","4ece615b2733e9e9","5d3db4e403b3db7b","f418dc8563c0be2a","b1b2bb8e2ca4589a"],"x":272.71414947509766,"y":487.2856607437134,"w":834.9999694824219,"h":209.35718822479248},{"id":"e17b9ae7a1f0461d","type":"group","z":"bff27e059752cb60","g":"1029acfc1e365877","name":"enforce a single connection","style":{"label":true},"nodes":["a394711dc77a08fb","216feb12291e096e","a60cbdd34ec7d4fc","17170a0e7c847f63"],"x":308.4286766052246,"y":804.7143402099609,"w":1192.571460723877,"h":110.85710144042969},{"id":"f34d62c6405b4352","type":"group","z":"bff27e059752cb60","g":"1029acfc1e365877","name":"handle communication with a connection","style":{"label":true},"nodes":["49b0663498a4eb84","5488428955c0dd92","3670ea0d392f6155","17c251b02ee74d23","ed230dfff61160c4","74ba18e32963446d"],"x":268.8571891784668,"y":1021.8570528030396,"w":834.9999694824219,"h":209.35718822479248},{"id":"4f54a8c419e2fb50","type":"group","z":"bff27e059752cb60","g":"b2459a7ed42bbb57","name":"enforce a single connection","style":{"label":true},"nodes":["0e5588ba5e03c313","07d118b297f6a5ae","50ca60c518e61c49","239af23282477454","9c50a2b367a6eb2b"],"x":308.4286766052246,"y":1339.0000267028809,"w":1192.571460723877,"h":160.6429271697998},{"id":"deeaf89f0c7b0895","type":"group","z":"bff27e059752cb60","g":"b2459a7ed42bbb57","name":"handle communication with a connection","style":{"label":true},"nodes":["25c462c9b63df338","0feec528669881fd","b80607305404e13e","5d06d6740c0f4e8e","1c2253f326456499","42c250bc3a108052"],"x":268.8571891784668,"y":1605.9285650253296,"w":834.9999694824219,"h":209.35718822479248},{"id":"c0d9ca36b10a7a41","type":"change","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"send prompt>","rules":[{"p":"payload","pt":"msg","t":"set","to":"prompt> ","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":941.7141189575195,"y":655.6428489685059,"wires":[["ce3d569a01e36814"]]},{"id":"ce3d569a01e36814","type":"tcp out","z":"bff27e059752cb60","g":"54e4c3fae17a3580","name":"","host":"","port":"","beserver":"reply","base64":false,"end":false,"tls":"","x":1354.8569412231445,"y":655.6428489685059,"wires":[]},{"id":"c01f45843fbf19e4","type":"switch","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"what payload?","property":"payload","propertyType":"msg","rules":[{"t":"eq","v":"exit","vt":"str"},{"t":"eq","v":"quit","vt":"str"},{"t":"cont","v":"hello","vt":"str"},{"t":"else"}],"checkall":"false","repair":false,"outputs":4,"x":717.1426849365234,"y":586.5713996887207,"wires":[["4ece615b2733e9e9"],["4ece615b2733e9e9"],["f418dc8563c0be2a"],["c0d9ca36b10a7a41"]]},{"id":"4ece615b2733e9e9","type":"change","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"quit and close connection","rules":[{"t":"set","p":"reset","pt":"msg","to":"true","tot":"bool"},{"t":"set","p":"payload","pt":"msg","to":"\"closed\" & \"\\n\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":971.7141189575195,"y":529.4999713897705,"wires":[["ce3d569a01e36814"]]},{"id":"5d3db4e403b3db7b","type":"switch","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"ignore closed connections","property":"_session.status","propertyType":"msg","rules":[{"t":"neq","v":"closed","vt":"str"}],"checkall":"false","repair":false,"outputs":1,"x":418.71414947509766,"y":528.2856607437134,"wires":[["b1b2bb8e2ca4589a"]]},{"id":"f418dc8563c0be2a","type":"change","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"obtain name of user","rules":[{"p":"payload","pt":"msg","t":"set","to":"\"hello, what is your name?\" & \"\\n\" & \"enter name> \"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":961.7141189575195,"y":592.5714101791382,"wires":[["ce3d569a01e36814"]]},{"id":"b1b2bb8e2ca4589a","type":"change","z":"bff27e059752cb60","g":"8ccba23ce4a6d1ec","name":"remove newlines from payload","rules":[{"p":"payload","pt":"msg","t":"set","to":"$replace($$.payload, \"\\n\",\"\")","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":470.14270782470703,"y":586.5713996887207,"wires":[["c01f45843fbf19e4"]]},{"id":"6ed338acd5d4f020","type":"erlstatemachine","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"","scope":["2fb1c9e4acd00e7c"],"emit_on_state_change":false,"x":728.9998168945312,"y":328.00004959106445,"wires":[["64614c1426867215"]]},{"id":"b42afac9028901f4","type":"tcp in","z":"bff27e059752cb60","g":"54e4c3fae17a3580","name":"","server":"server","host":"","port":"2424","datamode":"stream","datatype":"utf8","newline":"","topic":"","trim":false,"base64":false,"tls":"","x":149.14272689819336,"y":328.00004959106445,"wires":[["5d3db4e403b3db7b","269ef88b6e5dfe87"]]},{"id":"269ef88b6e5dfe87","type":"change","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"set action and payload \\n for the state machine","rules":[{"p":"action","pt":"msg","t":"set","to":"_session.status","tot":"msg"},{"p":"payload","pt":"msg","t":"set","to":"_session.id","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":438.28563690185547,"y":328.00004959106445,"wires":[["6ed338acd5d4f020"]]},{"id":"2fb1c9e4acd00e7c","type":"erlmodule","z":"bff27e059752cb60","g":"e5c9a8daced2036d","name":"","module_name":"ensure_single_connection","code":"-module(ensure_single_connection).\n\n-behaviour(gen_statem).\n\n-export([\n    start/0,\n    init/1,\n    callback_mode/0,\n    handle_event/4,\n    code_change/4,\n    terminate/3,\n    stop/0\n]).\n\ncallback_mode() -> handle_event_function.\n\n-define(KEEP_STATE(ReplyWith),\n    {keep_state, Data, [{reply, From, ReplyWith}]}\n).\n\n%% API.  This example uses a registered name name()\n%% and does not link to the caller.\nstart() ->\n    gen_statem:start({local, ?MODULE}, ?MODULE, [], []).\n\ninit([]) ->\n    State = disconnected,\n    Data = #{sessionid => none},\n    {ok, State, Data}.\n\n%% Mandatory callback functions\nstop() ->\n    gen_statem:stop(?MODULE).\nterminate(_Reason, _State, _Data) ->\n    void.\ncode_change(_Vsn, State, Data, _Extra) ->\n    {ok,State,Data}.\n\n%%\n%% handler function for state transistions\n%%\n\n\n%%\n%% ------------- Initiated actions\n%%\n%% Connection initiated and state is disconnected --> allow connection and\n%% store the SessionId associated with connection and move to state \"connected\".\nhandle_event(\n  {call, From},\n  {<<\"initiated\">>, SessionId},\n  disconnected,\n  #{ sessionid := none }\n) ->\n    {next_state, connected, #{sessionid => SessionId}, [{reply, From, <<\"ok\">>}]};\n\n%% Connection being initiated but state is already connected however SessionIds\n%% match so this is re-initiating the same connection --> ok\nhandle_event(\n  {call, From},\n  {<<\"initiated\">>, SessionId},\n  connected,\n  #{ sessionid := SessionId } = Data\n) ->\n    ?KEEP_STATE(<<\"ok\">>);\n\n%% Connection being initiated but state is already connected and SessionIds\n%% do not match --> not allowed. This is a fall through, if SessionIds did match\n%% then rule above would have matched.\nhandle_event({call, From}, {<<\"initiated\">>, _SessionId}, connected, Data) ->\n    ?KEEP_STATE(<<\"not_allowed\">>);\n\n%%\n%% ------------- Connected actions\n%%\n%% \"Connected\" actions is data being sent to server from client. If the data\n%% is being sent but the sessionid does not match, drop the connection. Else\n%% let the connection be - if we're connected and the session ids match.\n\n%% Data sent and session ids match --> ok\nhandle_event(\n  {call, From},\n  {<<\"connected\">>, SessionId},\n  connected,\n  #{ sessionid := SessionId } = Data\n) ->\n    ?KEEP_STATE(<<\"ok\">>);\n\n%% State is our current state is connected and data is being sent. The session\n%% IDs don't match --> not allowed\nhandle_event(\n  {call, From},\n  {<<\"connected\">>, _SessionId},\n  connected,\n  Data\n) ->\n    ?KEEP_STATE(<<\"not_allowed\">>);\n\n%% Data being sent but our current state is disconnected --> not allowed\nhandle_event({call, From}, {<<\"connected\">>, _SessionId}, disconnected, Data) ->\n    ?KEEP_STATE(<<\"not_allowed\">>);\n\n%%\n%% -------------- Closed action\n%%\n%% \"Closed\" action are generated when the connection was closed, either by the\n%% server or by the client.\n\n%% Current state is \"connected\" and the action is closed, the SessionIds match\n%% so the state becomese \"disconnected\" and session id is removed.\nhandle_event(\n  {call, From},\n  {<<\"closed\">>, SessionId},\n  connected,\n  #{ sessionid := SessionId }\n) ->\n    {next_state, disconnected, #{sessionid => none}, [{reply, From, <<\"ok\">>}]};\n\n%% Closed action, current state is \"connected\" and SessionIds do not match\n%% --> nothing to do, keep current state. No need to close a closed connection!\nhandle_event(\n  {call, From},\n  {<<\"closed\">>, SessionId},\n  connected,\n  Data\n) ->\n    ?KEEP_STATE(<<\"ok\">>);\n\n%% Current state is \"disconnected\" and a closed action happens --> do nothing.\nhandle_event({call, From}, {<<\"closed\">>, _SessionId}, disconnected, Data) ->\n    ?KEEP_STATE(<<\"ok\">>);\n\n%%\n%% Fall through.\nhandle_event({call, From} = EventType, Stiff, State, Data) ->\n    io:format(\"TEST (call): ~p ~p ~p ~p~n\",[EventType, Stiff, State, Data]),\n    ?KEEP_STATE(<<\"not_allowed\">>);\n\nhandle_event(EventType, Stiff, State, Data) ->\n    io:format(\"TEST : ~p ~p ~p ~p~n\",[EventType, Stiff, State, Data]),\n    {keep_state, Data}.\n","x":197,"y":95.28571510314941,"wires":[]},{"id":"64614c1426867215","type":"switch","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"close connection?","property":"payload","propertyType":"msg","rules":[{"t":"eq","v":"not_allowed","vt":"str"}],"checkall":"false","repair":false,"outputs":1,"x":1009.713996887207,"y":328.00004959106445,"wires":[["d6116b5c531ce565"]]},{"id":"d6116b5c531ce565","type":"change","z":"bff27e059752cb60","g":"1d162492dd79abb3","name":"close connection with \"too many \\n connections\" message","rules":[{"p":"reset","pt":"msg","t":"set","to":"true","tot":"bool"},{"p":"payload","pt":"msg","t":"set","to":"\"too many connections\" & \"\\n\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":1100.2855987548828,"y":410.2857475280762,"wires":[["ce3d569a01e36814"]]},{"id":"a50b8524d3ad6351","type":"tcp out","z":"bff27e059752cb60","g":"1029acfc1e365877","name":"","host":"","port":"","beserver":"reply","base64":false,"end":false,"tls":"","x":1629.5714721679688,"y":1194.4998989105225,"wires":[]},{"id":"dc4a457fb4252964","type":"tcp in","z":"bff27e059752cb60","g":"1029acfc1e365877","name":"","server":"server","host":"","port":"2525","datamode":"stream","datatype":"utf8","newline":"","topic":"","trim":false,"base64":false,"tls":"","x":145.2857666015625,"y":862.5714416503906,"wires":[["216feb12291e096e"]]},{"id":"a394711dc77a08fb","type":"erlstatemachine","z":"bff27e059752cb60","g":"e17b9ae7a1f0461d","name":"","scope":["2fb1c9e4acd00e7c"],"emit_on_state_change":false,"x":725.1428565979004,"y":862.5714416503906,"wires":[["a60cbdd34ec7d4fc"]]},{"id":"216feb12291e096e","type":"change","z":"bff27e059752cb60","g":"e17b9ae7a1f0461d","name":"set action and payload \\n for the state machine","rules":[{"p":"orig_payload","pt":"msg","t":"set","to":"payload","tot":"msg"},{"p":"action","pt":"msg","t":"set","to":"_session.status","tot":"msg"},{"p":"payload","pt":"msg","t":"set","to":"_session.id","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":434.4286766052246,"y":862.5714416503906,"wires":[["a394711dc77a08fb"]]},{"id":"a60cbdd34ec7d4fc","type":"switch","z":"bff27e059752cb60","g":"e17b9ae7a1f0461d","name":"close connection?","property":"payload","propertyType":"msg","rules":[{"t":"eq","v":"not_allowed","vt":"str"},{"t":"else"}],"checkall":"false","repair":false,"outputs":2,"x":1005.8570365905762,"y":862.5714416503906,"wires":[["17170a0e7c847f63"],["17c251b02ee74d23"]]},{"id":"17170a0e7c847f63","type":"change","z":"bff27e059752cb60","g":"e17b9ae7a1f0461d","name":"close connection with \"too many \\n connections\" message","rules":[{"p":"reset","pt":"msg","t":"set","to":"true","tot":"bool"},{"p":"payload","pt":"msg","t":"set","to":"\"too many connections\" & \"\\n\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":1335.0001373291016,"y":857.7143402099609,"wires":[["a50b8524d3ad6351"]]},{"id":"49b0663498a4eb84","type":"change","z":"bff27e059752cb60","g":"f34d62c6405b4352","name":"send prompt>","rules":[{"p":"payload","pt":"msg","t":"set","to":"prompt> ","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":937.8571586608887,"y":1190.214241027832,"wires":[["a50b8524d3ad6351"]]},{"id":"5488428955c0dd92","type":"switch","z":"bff27e059752cb60","g":"f34d62c6405b4352","name":"what payload?","property":"payload","propertyType":"msg","rules":[{"t":"eq","v":"exit","vt":"str"},{"t":"eq","v":"quit","vt":"str"},{"t":"cont","v":"hello","vt":"str"},{"t":"else"}],"checkall":"false","repair":false,"outputs":4,"x":713.2857246398926,"y":1121.1427917480469,"wires":[["3670ea0d392f6155"],["3670ea0d392f6155"],["ed230dfff61160c4"],["49b0663498a4eb84"]]},{"id":"3670ea0d392f6155","type":"change","z":"bff27e059752cb60","g":"f34d62c6405b4352","name":"quit and close connection","rules":[{"p":"reset","pt":"msg","t":"set","to":"true","tot":"bool"},{"p":"payload","pt":"msg","t":"set","to":"\"closed\" & \"\\n\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":967.8571586608887,"y":1064.0713634490967,"wires":[["a50b8524d3ad6351"]]},{"id":"17c251b02ee74d23","type":"switch","z":"bff27e059752cb60","g":"f34d62c6405b4352","name":"ignore closed connections","property":"_session.status","propertyType":"msg","rules":[{"t":"neq","v":"closed","vt":"str"}],"checkall":"false","repair":false,"outputs":1,"x":414.8571891784668,"y":1062.8570528030396,"wires":[["74ba18e32963446d"]]},{"id":"ed230dfff61160c4","type":"change","z":"bff27e059752cb60","g":"f34d62c6405b4352","name":"obtain name of user","rules":[{"p":"payload","pt":"msg","t":"set","to":"\"hello, what is your name?\" & \"\\n\" & \"enter name> \"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":957.8571586608887,"y":1127.1428022384644,"wires":[["a50b8524d3ad6351"]]},{"id":"74ba18e32963446d","type":"change","z":"bff27e059752cb60","g":"f34d62c6405b4352","name":"remove newlines from payload","rules":[{"p":"payload","pt":"msg","t":"set","to":"orig_payload","tot":"msg"},{"p":"payload","pt":"msg","t":"set","to":"$replace($$.payload, \"\\n\",\"\")","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":466.2857475280762,"y":1121.1427917480469,"wires":[["5488428955c0dd92"]]},{"id":"3aade96baaa76948","type":"tcp out","z":"bff27e059752cb60","g":"b2459a7ed42bbb57","name":"","host":"","port":"","beserver":"reply","base64":false,"end":false,"tls":"","x":1629.5714721679688,"y":1778.5714111328125,"wires":[]},{"id":"0a472fabd3d01e82","type":"tcp in","z":"bff27e059752cb60","g":"b2459a7ed42bbb57","name":"","server":"server","host":"","port":"2626","datamode":"stream","datatype":"utf8","newline":"","topic":"","trim":false,"base64":false,"tls":"","x":145.2857666015625,"y":1446.6429538726807,"wires":[["07d118b297f6a5ae"]]},{"id":"0e5588ba5e03c313","type":"erlstatemachine","z":"bff27e059752cb60","g":"4f54a8c419e2fb50","name":"","scope":["2fb1c9e4acd00e7c"],"emit_on_state_change":false,"x":725.1428565979004,"y":1446.6429538726807,"wires":[["50ca60c518e61c49"]]},{"id":"07d118b297f6a5ae","type":"change","z":"bff27e059752cb60","g":"4f54a8c419e2fb50","name":"set action and payload \\n for the state machine","rules":[{"p":"orig_payload","pt":"msg","t":"set","to":"payload","tot":"msg"},{"p":"action","pt":"msg","t":"set","to":"_session.status","tot":"msg"},{"p":"payload","pt":"msg","t":"set","to":"_session.id","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":434.4286766052246,"y":1446.6429538726807,"wires":[["0e5588ba5e03c313"]]},{"id":"50ca60c518e61c49","type":"switch","z":"bff27e059752cb60","g":"4f54a8c419e2fb50","name":"close connection?","property":"payload","propertyType":"msg","rules":[{"t":"eq","v":"not_allowed","vt":"str"},{"t":"else"}],"checkall":"false","repair":false,"outputs":2,"x":1005.8570365905762,"y":1446.6429538726807,"wires":[["239af23282477454"],["5d06d6740c0f4e8e"]]},{"id":"239af23282477454","type":"change","z":"bff27e059752cb60","g":"4f54a8c419e2fb50","name":"close connection with \"too many \\n connections\" message","rules":[{"p":"reset","pt":"msg","t":"set","to":"true","tot":"bool"},{"p":"payload","pt":"msg","t":"set","to":"\"too many connections\" & \"\\n\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":1335.0001373291016,"y":1441.785852432251,"wires":[["3aade96baaa76948"]]},{"id":"25c462c9b63df338","type":"change","z":"bff27e059752cb60","g":"deeaf89f0c7b0895","name":"send prompt>","rules":[{"p":"payload","pt":"msg","t":"set","to":"prompt> ","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":937.8571586608887,"y":1774.285753250122,"wires":[["3aade96baaa76948"]]},{"id":"0feec528669881fd","type":"switch","z":"bff27e059752cb60","g":"deeaf89f0c7b0895","name":"what payload?","property":"payload","propertyType":"msg","rules":[{"t":"eq","v":"exit","vt":"str"},{"t":"eq","v":"quit","vt":"str"},{"t":"cont","v":"hello","vt":"str"},{"t":"else"}],"checkall":"false","repair":false,"outputs":4,"x":713.2857246398926,"y":1705.214303970337,"wires":[["b80607305404e13e"],["b80607305404e13e"],["1c2253f326456499"],["25c462c9b63df338"]]},{"id":"b80607305404e13e","type":"change","z":"bff27e059752cb60","g":"deeaf89f0c7b0895","name":"quit and close connection","rules":[{"p":"reset","pt":"msg","t":"set","to":"true","tot":"bool"},{"p":"payload","pt":"msg","t":"set","to":"\"closed\" & \"\\n\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":967.8571586608887,"y":1648.1428756713867,"wires":[["3aade96baaa76948"]]},{"id":"5d06d6740c0f4e8e","type":"switch","z":"bff27e059752cb60","g":"deeaf89f0c7b0895","name":"ignore closed connections","property":"_session.status","propertyType":"msg","rules":[{"t":"neq","v":"closed","vt":"str"}],"checkall":"false","repair":false,"outputs":1,"x":414.8571891784668,"y":1646.9285650253296,"wires":[["42c250bc3a108052"]]},{"id":"1c2253f326456499","type":"change","z":"bff27e059752cb60","g":"deeaf89f0c7b0895","name":"obtain name of user","rules":[{"p":"payload","pt":"msg","t":"set","to":"\"hello, what is your name?\" & \"\\n\" & \"enter name> \"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":957.8571586608887,"y":1711.2143144607544,"wires":[["3aade96baaa76948"]]},{"id":"42c250bc3a108052","type":"change","z":"bff27e059752cb60","g":"deeaf89f0c7b0895","name":"remove newlines from payload","rules":[{"p":"payload","pt":"msg","t":"set","to":"orig_payload","tot":"msg"},{"p":"payload","pt":"msg","t":"set","to":"$replace($$.payload, \"\\n\",\"\")","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":466.2857475280762,"y":1705.214303970337,"wires":[["0feec528669881fd"]]},{"id":"9c50a2b367a6eb2b","type":"erlsupervisor","z":"bff27e059752cb60","g":"4f54a8c419e2fb50","name":"","scope":["0e5588ba5e03c313"],"supervisor_type":"static","strategy":"one_for_one","auto_shutdown":"never","intensity":"100","period":"5","child_type":"worker","child_restart":"permanent","child_shutdown":"infinite","child_shutdown_timeout":"0","x":700,"y":1380.0000267028809,"wires":[[]]}]