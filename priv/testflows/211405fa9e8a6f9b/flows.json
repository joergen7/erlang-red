[{"id":"211405fa9e8a6f9b","type":"tab","label":"[.docu] Supervisor node architecture","disabled":false,"info":"<script>\n$(function(){\n    $('#flowtitle').html($('#flowtitle').text().replace(\"[.docu]\",\"\"));\n})\n</script>\n\n<small><i>[Share link](https://flows.red-erik.org/f/211405fa9e8a6f9b)</i></small>\n\n## Supervisor node Erlang architecture\n\nThis is a continuation of [function node architecture](https://flows.red-erik.org/f/1fd621a674360b5d) and describes the workings of the [supervisor node](https://github.com/gorenje/erlang-red/blob/abcb5d3e5ddeb817b75b45d0f27b8ed5cae5a063/src/nodes/ered_node_erlsupervisor.erl). \n\nThis example is a single supervisor node supervising a single node, I won't go into the the details of [supervisor trees](https://flows.red-erik.org/f/83c5e1824f32abec) or [supervisors of supervisors of supervisor of ....](https://flows.red-erik.org/f/e447b0048a5983b5) - those are left of a cold winters day to describe.\n\n## Top level architecture\n\n```mermaid\n%% change this to LR Node-RED like UML\ngraph TB\n35330836e77bc5c7@{ shape: \"fr-rect\", label: \"Supervisor Node \\n &lt;ered_nodes.erl&gt;\" } -- \"create_pids_for_nodes#47;2\" --> 5914bd748c211abf@{ shape: \"rect\", label: \"ered_node_erlsupervisor \\n &lt;ered_node&gt;\" }\n5914bd748c211abf@{ shape: \"rect\", label: \"ered_node_erlsupervisor \\n &lt;ered_node&gt;\" } -- \"exit#40;normal#41;\" --> d48ecbeb4b63f6e6@{ shape: \"rect\", label: \"ered_supervisor_manager \\n &lt;supervisor&gt;\" }\n5914bd748c211abf@{ shape: \"rect\", label: \"ered_node_erlsupervisor \\n &lt;ered_node&gt;\" } -- \"ered_node_erlsupervisor:create_children#47;3\" --> 6e828720bfd223d5@{ shape: \"rect\", label: \"supervisor \\n &lt;supervisor&gt;\" }\n4d3474827cacd5c3@{ shape: \"st-rect\", label: \"system \\n &lt;ered_nodes.erl&gt;\" } -. \"handle_event#40;#123;registered#125;#41;#47;2\" .-> 5914bd748c211abf@{ shape: \"rect\", label: \"ered_node_erlsupervisor \\n &lt;ered_node&gt;\" }\n6e828720bfd223d5@{ shape: \"rect\", label: \"supervisor \\n &lt;supervisor&gt;\" } -- \"ered_supervisor_manager:start_link#47;3\" --> d48ecbeb4b63f6e6@{ shape: \"rect\", label: \"ered_supervisor_manager \\n &lt;supervisor&gt;\" }\nd48ecbeb4b63f6e6@{ shape: \"rect\", label: \"ered_supervisor_manager \\n &lt;supervisor&gt;\" } -. \"! #123;'DOWN' ... shutdown#125;\" .-> 5914bd748c211abf@{ shape: \"rect\", label: \"ered_node_erlsupervisor \\n &lt;ered_node&gt;\" }\nd48ecbeb4b63f6e6@{ shape: \"rect\", label: \"ered_supervisor_manager \\n &lt;supervisor&gt;\" } -. \"! 'EXIT', normal\" .-> 6f2cc3cda256f2c8@{ shape: \"rect\", label: \"function 2 \\n &lt;ered_node&gt;\" }\nd48ecbeb4b63f6e6@{ shape: \"rect\", label: \"ered_supervisor_manager \\n &lt;supervisor&gt;\" } -- \"ered_startup:spin_up_and_link_node#47;2\" --> 6f2cc3cda256f2c8@{ shape: \"rect\", label: \"function 2 \\n &lt;ered_node&gt;\" }\nsubgraph at flow start up time\n5914bd748c211abf\n4d3474827cacd5c3\nsubgraph start supervisor manager\n6e828720bfd223d5\nd48ecbeb4b63f6e6\nend\nend\n```\n\n## Terminology\n\nIn the flow-chart:\n\n- rectangles are Erlang processes\n- solid arrows are function calls that create processes\n- dotted arrows are Erlang messages being sent between processes\n\nThe \"system\" is simply the running instance of Erlang-Red and the framed rectangle is the JSON description of the supervisor node (in a certain sense).\n\n## Explanation\n\nThe flowchart presents the start up mechanism of the <a class=\"ahl-node-only\" data-ids=\"94ae573ea1b956d3\">supervisor</a> node. The node is first spun up via the `create_pids_for_nodes/2` function which triggers the [`ered_node:start/2`](https://github.com/gorenje/erlang-red/blob/abcb5d3e5ddeb817b75b45d0f27b8ed5cae5a063/src/ered_node.erl#L22-L23) callback. The flow creation process is presented in a [separate document](https://flows.red-erik.org/f/2d51a745ca17dc05).\n\nOnce that has happened, the supervisor node process receives a `registered/2` event and spins up its children using the `ered_supervisor_manager` module. This creates the supervisor responsible for starting and stopping the children of the supervisor node. It uses the configuration of the node to spin up child processes for all the nodes that the supervisor node is supervising. It spins up the child processes using the `ered_startup:spin_up_and_link_node/2` function.\n\nThe ered_supervisor_manager dies when the intensity-over-period is reached. This death would also take out the process representing the supervisor node - since supervisors can only be started *linked* to their calling process. As the [mantra](https://blog.openmindmap.org/blog/erlang-red#nodes-will-never-die) is *node processes shall never die*, it is not desirable that the ered_supervisor_manager should also take down the supervisor node process. Hence there is a supervisor between the node process and the manager process: the \"supervisor &lt;supervisor&gt;\" process in the diagram. That supervisor is configured to neither restart the manager nor to die itself. It buffers the death of the manager and prevents the supervisor node process from dying.\n\nWhen the supervisor manager does die, the supervisor node process is informed via `'DOWN'` message that is sent to the supervisor node process because the process is monitoring the manager process. A monitor is setup when the supervisor manager process sends a `{supervisor_started, SupMgrPid}` message to the supervisor node process.\n\nThis setup works fine if this supervisor node is not being supervised by another supervisor, i.e., supervisor-of-supervisor pattern. The problem there is the death of the ered_supervisor_manager has to be propagated up the supervisor chain. But this node does everything to prevent itself from dying when the supervisor dies. In a supervisor-of-supervisor pattern, this node needs to die since the supervisor is supervising the node process NOT the process of the supervisor that dies when the children die.\n\nLuckily what happens is that this node receives a message when the supervisor goes down - the \"{'DOWN', ...}\" message. It receives this message to alter its status - from started to dead. What we do is set a flag on the NodeDef of this node to tell it to go down if and only if its supervisor goes down. We only set this flag if the supervisor node is being supervised. \n\nWhen the node goes down, the supervisor supervising it, restarts the entire node.\n\n## Discussion\n\n### Nested supervisors\n\nWhat is not shown is the *chicken & egg* issues surrounding the configuration of supervisor nodes. As part of the initialisation phase before starting a flow, nodes that are managed by a supervisor will not be started by Erlang-Red directly rather indirectly via the supervisor. This causes issues when supervisors supervise supervisors, i.e., nesting of supervisors.\n\nBoth issues are addressed in the `ered_startup:create_pids_for_nodes/2` call. It is responsible for first identifying all supervisors, then removing the nodes they supervise from the list of nodes to be started and finally it defines an ordering of how supervisors are started - since those start other supervisors that then start node processes. These tasks are covered in the `ered_node_erlsupervisor:extract_nodes/3`, `ered_nodes:supervisor_filter_nodes/5` and `ered_nodes:extract_supervisors/1` functions.\n\n### Buffering the supervisor - `supervisor <supervisor>` process\n\nThe \"buffer supervisor\" is a thorn in the backside however I have not found a better approach to the need of keeping the supervisor node process alive when the supervisor dies. It can definitely die when failure rate get to intensive, i.e., instensity versus period. Part of the problem is that a supervisor process cannot to spun up \"off-the-clock\", i.e., without being linked to the parent process. It is this linkage the causes the issue: it pulls the supervisor node process down with it when the supervisor fails.\n\nMuch as the [function node](https://flows.red-erik.org/f/1fd621a674360b5d), which has up to two processes *per* Erlang-Red message, there are valid reasons for having the \"buffer supervisor\". I am aware of the \"let it fail\"-mantra of Erlang, however if everything fails then there is nothing to start it up again. Perhaps having the supervisor node processing being a `supervisor` behaviour instead of a `ered_node` behaviour would help? No it does not since the supervisor behaviour *cannot* handle Erlang messages sent to it from other processes. Combining the two behaviours (`ered_node` and `supervisor`) is not possible because there is an overlap in the `init/1` function. The ered_node behaviour inherits the `init/1` function from the `gen_server` behaviour that it also implements.\n\n### Supervising the Supervisor\n\nAs mentioned above, there are behavioural changes when the supervisor knows its being supervised. All nodes that are being managed by a supervisor are informed of this during the start up phase (not shown above) by being sent the `{being_supervised, ...}` message. This message is sent right after the `registered` message shown above.\n\nOnce the supervisor node knows it is being monitor, it will shutdown when its supervisor manager dies. That is, when the intensity/period configuration becomes critical and the manager stops restarting processes.\n\nAnother task the supervisor node process has to perform - if it is being supervised - is to shutdown any managers *if* it is told to shut down. This happens when the supervising supervisor restarts process via a restart policy of \"one for all\" or \"rest for one\", meaning a healthy process is restarted because an unhealthy one dies.\n\nThis done by the supervisor node process sending the manager a message via the `exit(normal)` function. This then ensures that the supervisor manager shuts down all nodes being managed by the supervisor node.\n\n## Code\n\n- [ered_node_erlsupervisor.erl](https://github.com/gorenje/erlang-red/blob/abcb5d3e5ddeb817b75b45d0f27b8ed5cae5a063/src/nodes/ered_node_erlsupervisor.erl)\n- [ered_supervisor_manager.erl](https://github.com/gorenje/erlang-red/blob/abcb5d3e5ddeb817b75b45d0f27b8ed5cae5a063/src/managers/ered_supervisor_manager.erl)\n- [ered_nodes.erl](https://github.com/gorenje/erlang-red/blob/abcb5d3e5ddeb817b75b45d0f27b8ed5cae5a063/src/ered_nodes.erl)\n- [ered_ndoe.erl](https://github.com/gorenje/erlang-red/blob/abcb5d3e5ddeb817b75b45d0f27b8ed5cae5a063/src/ered_node.erl) behaviour\n\n","env":[{"name":"ERED_TIMEOUT","value":"1","type":"num"}]},{"id":"e8765b1cd757b1d3","type":"inject","z":"211405fa9e8a6f9b","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":187,"y":506,"wires":[["6899b24a5114a6b8"]]},{"id":"03d96dfe714b55a0","type":"debug","z":"211405fa9e8a6f9b","name":"debug 1","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"","statusType":"counter","x":745,"y":506,"wires":[]},{"id":"6899b24a5114a6b8","type":"function","z":"211405fa9e8a6f9b","name":"function 2","func":"%% Code here is wrapped in a fun (Msg) call\n%% fun (Msg) ->\n    Msg\n%% end.\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":453,"y":506,"wires":[["03d96dfe714b55a0"]]},{"id":"94ae573ea1b956d3","type":"erlsupervisor","z":"211405fa9e8a6f9b","name":"","scope":["6899b24a5114a6b8"],"supervisor_type":"static","strategy":"one_for_one","auto_shutdown":"never","intensity":"1","period":"5","child_type":"worker","child_restart":"permanent","child_shutdown":"brutal_kill","child_shutdown_timeout":"0","x":447,"y":374.5,"wires":[[]]}]