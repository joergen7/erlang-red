[{"id":"2d51a745ca17dc05","type":"tab","label":"[.docu] Erlang-Red flow startup","disabled":false,"info":"<script>\n$(function(){\n    $('#flowdatacontainer').hide();\n    $('#flowtitle').html($('#flowtitle').text().replace(\"[.docu]\",\"\")).css('font-size', '1.9em');\n})\n</script>\n\n<small><i>[Share](https://flows.red-erik.org/f/2d51a745ca17dc05)</i></small>\n\nA visualisation of [ered_startup](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/ered_startup.erl) module which is responsible for spinning up all processes required for the execution of a flow.\n\nFlow nodes are represented by an Erlang processes, each node has a main process that is independent of all other node processes. Nodes are configured with their immediate downstream connections. Processes use this configuration to send messages to other Erlang processes representing those downstream nodes.\n\nDescribed here is how these processes are started from a JSON description of nodes and flows. This description focuses solely on the initialisation of Erlang-Red flows when these are deployed. This description does not concern itself with the Erlang supervised [services](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/erlang_red_sup.erl) started at Erlang-Red start up time. \n\nThis description comprises three parts, the first two described the step-by-step sequence that creates Erlang processes from JSON node descriptions. The third part describes the usage of that sequence to instantiate a flow as Erlang processes and pass a message through that flow.\n\n## Start up - Phase one\n\n```mermaid\n%% Generated by the Flow2UML Node @ https://flowhub.org/flow2uml\n%% change direction to LR for Node-RED left-to-right UML\ngraph LR\n647f1caf18f4e461@{ shape: \"braces\", label: \"Outside World\" } -- \"create_pids_for_nodes#47;2\" --> cd65242359acde9d@{ shape: \"doc\", label: \"ered_startup.erl\" }\ncd65242359acde9d@{ shape: \"doc\", label: \"ered_startup.erl\" } -- \"**#40;1#41;** call_to\" --> f7b57f5fa2684033@{ shape: \"text\", label: \"store_config_nodes#47;2\" }\ncd65242359acde9d@{ shape: \"doc\", label: \"ered_startup.erl\" } -- \"**#40;2#41;** call_to\" --> 06d71e4d226a0b66@{ shape: \"text\", label: \"install_module_node_code#47;2\" }\ncd65242359acde9d@{ shape: \"doc\", label: \"ered_startup.erl\" } -- \"**#40;3#41;** call_to\" --> 6f2a3728abcf40e8@{ shape: \"text\", label: \"extract_supervisors#47;1\" }\ncd65242359acde9d@{ shape: \"doc\", label: \"ered_startup.erl\" } -- \"**#40;4#41;** call_to\" --> 4b74abd49857f467@{ shape: \"text\", label: \"supervisor_filter_nodes#47;5\" }\ncd65242359acde9d@{ shape: \"doc\", label: \"ered_startup.erl\" } -- \"**#40;5#41;** call_to\" --> 993f43fc0fd83c72@{ shape: \"text\", label: \"create_pids_for_nodes#47;3\" }\nf7b57f5fa2684033@{ shape: \"text\", label: \"store_config_nodes#47;2\" } -- \"store_config_node\" --> deebe7665f77dc9a@{ shape: \"lin-cyl\", label: \"ered_config_store \\n &lt;gen_server&gt;\" }\n06d71e4d226a0b66@{ shape: \"text\", label: \"install_module_node_code#47;2\" } -- \"install#47;2\" --> b8a1bc7329daec62@{ shape: \"notch-rect\", label: \"ered_node_erlmodule\" }\n6f2a3728abcf40e8@{ shape: \"text\", label: \"extract_supervisors#47;1\" } == \"Supervisors\" ==> cd65242359acde9d@{ shape: \"doc\", label: \"ered_startup.erl\" }\n4b74abd49857f467@{ shape: \"text\", label: \"supervisor_filter_nodes#47;5\" } -- \"extract_nodes#47;2\" --> 94123abe4da26501@{ shape: \"notch-rect\", label: \"Supervisor Module\" }\n993f43fc0fd83c72@{ shape: \"text\", label: \"create_pids_for_nodes#47;3\" } == \"Pids\" ==> 647f1caf18f4e461@{ shape: \"braces\", label: \"Outside World\" }\nsubgraph \"ered_startup:create_pids_for_nodes#47;2\"\ncd65242359acde9d\nf7b57f5fa2684033\n06d71e4d226a0b66\n6f2a3728abcf40e8\n4b74abd49857f467\n993f43fc0fd83c72\nend\n```\n*Function calls are ordered and shown in **(1)** numbering. Thick arrows are return values, thin arrows are function calls.*\n\nThe `{ Outside World }` passes a collection of nodes to the `create_pids_for_nodes/2` function. These nodes contain all the nodes that define a Node-RED flow *representation*, which include:\n\n- `tab` node that represents a collection of nodes grouped by a tab within the Node-RED flow editor. The ID of the tab node defines the `z` value for each node that is contained in that tab. A tab node also defines environment parameters for the entire flow, i.e., group of nodes.\n- `config` nodes that define connection details (for example) to third party services. Configuration details are stored in config nodes and shared amongst multiple instances of service nodes. \n- `service` nodes represent connections to third-party services such as MQTT or HTTP connections. These are configured using config nodes.\n- `group` nodes that represent groupings of within a tab within the Node-RED flow editor. The ID of the group node defines the `g` attribute of nodes that belong to the group.\n- `junction` node that represent junction points with flows. Their main purpose is visually connecting many streams of data into a single connection. Any messages received by a junction node are unaltered and transparently passed to all the junctions downstream connections.\n- All other nodes that represent the logic of the flow. The behaviour and interaction of each of these nodes are defined by their own [module](https://github.com/gorenje/erlang-red/tree/82075b02258dfb31a566213c168c890c4564dafd/src/nodes). The [startup module](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/ered_startup.erl#L292-L331) defines the mapping between node type and module for handling that type. This mapping needs to be updated for each new node type.\n\nDuring the initial creation time of the processes, the start up process loops through the collection of nodes several times. For example, to store the config nodes, all nodes are iterated through. To install module nodes, all nodes are iterated through. This is done because there is no order defined in flow JSON files as passed to the server. A Node-RED flow JSON file consists of a flat array of objects (maps). This means that configuration nodes, for example, may be located anywhere in this array, even *after* the service nodes that utilise these config nodes.\n\nAs there is an implicit dependency between service nodes that use a configuration node or a function node that makes use of a module node, it is import to retrieve and store config nodes first and install module nodes first before spinning up service and function nodes that utilise these nodes.\n\nPhase one is therefore concerned with pre-initialisation steps, a kind of ordering of the flow and ensuring that nodes can be started with all their dependencies already available.\n\n### Description of steps\n\nAs described above, the first action is to extract configuration details from the flow:\n\n- **(1)** call to `store_config_nodes/2` takes the node collection that define a flow selects all config nodes. What is a config node? Node-RED provides no help there and again it is a [look-up table](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/ered_startup.erl#L355-L360) that provides the answer. A hard-coded look up table is not a long term solution, it's a stop-gap solution.\n\n  Node-RED allows node packages to define global objects that can be accessed by service nodes. It provides APIs for doing that. Erlang-Red provides a [config store](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/servers/ered_config_store.erl) service as the centralised global store. At the time of writing, this store is a simple gen_server with a lookup table as state.\n\n  Storage of configuration nodes is done before the service nodes are started. Services nodes are started in step **(4)** of phase **two** below. Access to the config store is exampled by the [mqtt node](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/nodes/ered_node_mqtt_in.erl#L239). Each service node is configured with a global unique ID reference to the config nodes that provides it configuration.\n\n- **(2)** call to `install_module_node_code/2` allows for code inject into Erlang-Red. [Module nodes](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/nodes/ered_node_erlmodule.erl) define modules for use with the event handler and state machine behaviour nodes. **No** checks are done of the correctness nor security of Erlang code injected via the Erlang module node.\n\n  Again modules defined by the module node can be used by other nodes and therefore must be installed before those nodes are started. Security concerns are clear and modules should be *used with caution*.\n\n  To install node code, the `ered_node_erlmodule:install/2` function is called with the node definition containing the Erlang module code. The node definition is the map representation of the original JSON object definition of the node.\n\n- **(3)** call to `extract_supervisors/1` retrieves all the supervisors from the collection of nodes. Supervisor nodes completely manage the lifecycle of the nodes that it supervises. This step *extracts* from the collection of flow nodes, all supervisor nodes and creates two lists of nodes: supervisors and non-supervisors.\n\n  In the case of supervisors of supervisors, both nodes are classified as *supervisors* for the purpose of this splitting of the node definitions. What defines a supervisor? Again this is done using a hard-coded, sub-optimal [lookup table](https://github.com/gorenje/erlang-red/blob/075d2c2362b50d8bc5f602656c2740553413028e/src/ered_startup.erl#L364-L370).\n\n- **(4)** call to `supervisor_filter_nodes/5` has the responsibility of further splitting the non-supervisor nodes into those that are supervised and those that are not supervised. Supervised nodes are removed from the node list and attached to their supervisor node.\n\n  This step is slightly complicated since to support a supervisor-of-a-supervisor-of-a-supervisor-of... pattern it is necessary that nodes are only attached to their supervisor if these have all their nodes attached. If a supervisors that are being supervised are defined first, then this cannot happen in one iteration through the list of nodes.\n\n  The collection of nodes has no order so this step iterates multiple times through the list of nodes until all nodes (that have a supervisor) have been attached to their supervisor and that supervisor is potentially attached to its supervisor and that supervisor is also attached to its supervisor. It's supervisors all the way up.\n\n  It is not supported that one node has two *direct* supervisors, i.e., the node would belong to two supervisors. It is possible though that a node has two or more hierarchical supervisors.\n\n  Each supervisor selects its own list of nodes by defining the `SupervisourModule:extract_nodes/3` function that returns a reduced list of nodes if all nodes that it is supervising were found in that list, else the original list of nodes is returned. The iteration continues with the next supervisor node until all supervisor nodes have been configured.\n\n  For the purposes of this iteration, supervisor nodes are part of the node list but only once these have obtained the nodes for which they are responsible. Supervisors add themselves to the list by including themselves as part of the reduced list of nodes which is passed back.\n\n- **(5)** call to `create_pids_for_nodes/3` which is passed a single collection of nodes with each node either being a supervisor or a service node or an internal logic node. This is list contains only nodes for which a Erlang process should be started. The create process IDs for nodes function does not distinguish between nodes, it tells each and every node to start an Erlang process for itself.\n\nThe details of which are described below in phase two.\n\n## Start up - Phase two\n\n```mermaid\n%% Generated by the Flow2UML Node @ https://flowhub.org/flow2uml\n%% change direction to LR for Node-RED left-to-right UML\ngraph LR\nfd298b0409083e41@{ shape: \"text\", label: \"create_pids_for_nodes#47;3\" } -- \"call_to\" --> 7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" }\n7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" } == \"Pid\" ==> fd298b0409083e41@{ shape: \"text\", label: \"create_pids_for_nodes#47;3\" }\n7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" } -- \"**#40;1#41;** call_to\" --> 020edf6a03f5f1e1@{ shape: \"text\", label: \"node_type_to_module#47;2\" }\n7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" } -- \"**#40;2#41;** call_to\" --> 771995a172e88ca0@{ shape: \"text\", label: \"get_node_name#47;2\" }\n7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" } -- \"**#40;3#41;** call_to\" --> 5c278940932c7d45@{ shape: \"text\", label: \"clear_pg_group#40;GrpName#41;\" }\n7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" } -- \"**#40;4#41;** call_to\" --> 7c90b2efc29436de@{ shape: \"text\", label: \" Module:start#47;2\" }\n7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" } -- \"**#40;5#41;** call_to\" --> b610359d7e58d2d3@{ shape: \"text\", label: \"gen_server:call#40;Pid, #123;registered, WsName, Pid#125;#41;,\" }\n020edf6a03f5f1e1@{ shape: \"text\", label: \"node_type_to_module#47;2\" } == \"Module\" ==> 7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" }\n771995a172e88ca0@{ shape: \"text\", label: \"get_node_name#47;2\" } == \"GrpName\" ==> 7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" }\n7c90b2efc29436de@{ shape: \"text\", label: \" Module:start#47;2\" } == \"Pid\" ==> 7d549ef8f1abdf52@{ shape: \"text\", label: \"spin_up_node#47;2\" }\n7c90b2efc29436de@{ shape: \"text\", label: \" Module:start#47;2\" } -- \"call_to\" --> 1587728bde29a151@{ shape: \"text\", label: \"spin_up_and_link_node#47;2\" }\nsubgraph \" \"\n7d549ef8f1abdf52\n020edf6a03f5f1e1\n771995a172e88ca0\n5c278940932c7d45\n7c90b2efc29436de\nb610359d7e58d2d3\nend\n```\n*Function calls are ordered and shown in **(1)** numbering. Thick arrows are return values, thin arrows are function calls.*\n\nThe `create_pids_for_nodes/3` function is a tail-recursion function that calls `spin_up_node/2` for each node in the list given to it. This function is related to `create_pids_for_nodes/2` (arity 2) in that it does the process creation. Phase one cleansed and prepared the node list, phase two spins up the Erlang processes for nodes.\n\n### Steps \n\n- **(1)** call to `node_type_to_module/2` which returns the module corresponding to the node type. As described above, this is a sub-optimal solution of having a hard-coded lookup table in the Erlang code. But for now it works. The function returns an Erlang `Module` which will be used to start the node process for the node. This happens in step 4 below.\n\n- **(2)** call to `get_node_name/2` provides a unique name for this process, across all connected clients. Because Erlang-Red can be used by multiple clients, there needs to be a scoping across those clients. Each client can execute each flow with *their* parameters and get *their* results. This requirement implies that there are - in fact - multiple processes for each node.\n\n  To implement this and to avoid flooding the atom registry, I am using a `pg`-based mapping between node and process based on the web-socket id of the client. This mapping is respected when nodes send messages to each other. How this works is by defining [`pg`](https://www.erlang.org/doc/apps/kernel/pg.html) groups using a specific [naming convention](https://github.com/gorenje/erlang-red/blob/075d2c2362b50d8bc5f602656c2740553413028e/src/ered_nodes.erl#L106). Each group contains the process ID of the current instance of the node for that web-socket, i.e., client.\n\n  This setup has the added bonus that if node processes are restarted by a supervisor nodes, inter-node communication continues unabated. This is because each time a node sends another node a message, it does a lookup in the `pg` table for the group that contains the process id of the target node. Since the group name contains the web-socket ID, all inter-node communication is automagically scoped by the client.\n\n  This could be done just as well by using the `erlang:register` functionality to give processes names. However this would end up polluting the atom namespace and risking the overflowing of that atom registry. Erlang has limitations on atom counts but which can be increased at start up time.\n\n- **(3)** call to `clear_pg_group/1` when a new process is started any existing processes are removed from the group. Normally this group should contain exactly one process and that is [enforced](https://github.com/gorenje/erlang-red/blob/075d2c2362b50d8bc5f602656c2740553413028e/src/ered_nodes.erl#L111-L121) however adding extra processes to this group to monitor inter-node communication is a possible extension.\n\n  Monitoring of message passing between nodes is already possible using the [message tracing](https://github.com/gorenje/erlang-red/commit/512b5e16a7f793fd1ab1974cc90a1e176c992b9b) feature, and in my opinion, is something that is essential to any visual flow based solution. This feature can be activated *without* redeployment of flows. The Node-RED way of doing this is by adding a debug node and redeploying the flow to activate the debug node. But that has the downfall of disturbing a running system that might well be magically fixed by a redeploy - *have you tried turning it on and off again?*.\n\n  It is a bugbear of many Node-RED users and something that I originally fixed in Node-RED using the [introspection](https://flows.nodered.org/node/@gregoriusrippenstein/node-red-contrib-introspection) node package. That package does the same message tracing in Node-RED, i.e., any node can be monitored and no redeployment is necessary. This is a good example of implementation of ideas that can be shared across visual solutions: it does not matter whether Node-RED or Erlang-Red, message tracing is a good idea and provides important insights into the workings of flows.\n\n- **(4)** call to `Module:start/2` finally spins up the process for the node. Since all node modules implement the `ered_node` behaviour, the excitiing stuff is actually in the [start function of ered_node](https://github.com/gorenje/erlang-red/blob/075d2c2362b50d8bc5f602656c2740553413028e/src/ered_node.erl#L56-L60). Also note that the `ered_node` behaviour implements the `gen_server` behaviour that then makes all nodes compatible with the supervisor behaviour and hence the [supervisor](https://flows.red-erik.org/f/211405fa9e8a6f9b) node.\n\n  The `start/1` function also allows node modules to perform node specific functionality at start up time. However because the process ID of the node is not known at that point, most of the initialisation of the node is done in the next and final step.\n\n- **(5)** call to `gen_server:call(Pid, {registered, WsName, Pid})` on each node process that was created. This call is performed immediately after the start functionality has completed. This call allows the node to register itself - using its own process id - with services that it requires to function correctly.\n\n  A process cannot rely on any particular other process running at this point. Nodes are started in sequence and this step is performed as part of that sequence. As mentioned above, no guarantee of node order is given nor made. No use case has yet arisen needing a trigger to be fired *after* all processes for a flow had been started. If such an use-case arises, then a further step will be added.\n\n  Node processes can rely on the [services](https://github.com/gorenje/erlang-red/blob/075d2c2362b50d8bc5f602656c2740553413028e/src/erlang_red_sup.erl) having been started and being accessible. It is with these services that nodes register themselves in this step.\n\nFinally the process ids are passed up the call chain and the flow has been started. If there are third party services such as MQTT listeners, then messages might be generated straight away. The next section will describe a flow being deployed via the flow editor and the generation of an initial message via an inject node.\n\n## Flow instantiation and message triggering\n\n```mermaid\n%% Generated by the Flow2UML Node @ https://flowhub.org/flow2uml\n%% change direction to LR for Node-RED left-to-right UML\ngraph TB\n9b62183f75d29ea6@{ shape: \"braces\", label: \"Deploy \\n &lt;Flow Editor&gt;\" } -- \"JSON string\" --> 374844f0a340e840@{ shape: \"rounded\", label: \"Deploy Route \\n &lt;ered_http_nodered_flow_deploy_handler&gt;\" }\n15346d38f116f3ac@{ shape: \"rect\", label: \"Startup \\n &lt;ered_startup.erl&gt;\" } == \"ProcessIDs\" ==> 01041555183d1b0b@{ shape: \"rounded\", label: \"Compute Engine \\n &lt;ered_compute_engine.erl&gt;\" }\n01041555183d1b0b@{ shape: \"rounded\", label: \"Compute Engine \\n &lt;ered_compute_engine.erl&gt;\" } == \"&lt;&lt;#123;#34;rev#34;:#34;fed00d06#34;#125;&gt;&gt;\" ==> 374844f0a340e840@{ shape: \"rounded\", label: \"Deploy Route \\n &lt;ered_http_nodered_flow_deploy_handler&gt;\" }\n01041555183d1b0b@{ shape: \"rounded\", label: \"Compute Engine \\n &lt;ered_compute_engine.erl&gt;\" } -- \"create_pids_for_nodes#47;2\" --> 15346d38f116f3ac@{ shape: \"rect\", label: \"Startup \\n &lt;ered_startup.erl&gt;\" }\n01041555183d1b0b@{ shape: \"rounded\", label: \"Compute Engine \\n &lt;ered_compute_engine.erl&gt;\" } -. \"Pid ! #123; stop #125;\" .-> 8e9bfb43fbc19e6c@{ shape: \"rect\", label: \"Node Process\" }\n374844f0a340e840@{ shape: \"rounded\", label: \"Deploy Route \\n &lt;ered_http_nodered_flow_deploy_handler&gt;\" } -- \"NodeDefinitions - List of Maps \" --> 01041555183d1b0b@{ shape: \"rounded\", label: \"Compute Engine \\n &lt;ered_compute_engine.erl&gt;\" }\n374844f0a340e840@{ shape: \"rounded\", label: \"Deploy Route \\n &lt;ered_http_nodered_flow_deploy_handler&gt;\" } == \"&lt;&lt;#123;#34;rev#34;:#34;fed00d06#34;#125;&gt;&gt;\" ==> 9b62183f75d29ea6@{ shape: \"braces\", label: \"Deploy \\n &lt;Flow Editor&gt;\" }\n```\n\nScenario: **Deploy button is clicked**\n\nAn initial JSON string is created by the flow editor containing all flow tabs and nodes within those flow tabs. This JSON string is sent to the server and is picked up by the deploy route. The server converts the JSON to a list of maps and passes that list on to the compute engine responsible for managing flow creation.\n\nThe compute engine first retrieves all the relevant `pg` groups for the flow being deployed. Having a naming convention for these groups, it is a matter of using the web-socket ID to create a group prefix. Each `pg` group name is checked against this prefix. Each member of each of group that has the prefix is sent a `stop` message. Thus any existing processes are stopped and cleansed away and all groups are now empty.\n\nThe stop messages are sent *off the clock* meaning that existing processes are being shutdown while new processes are being started in their place. No use-case has arisen where this overlap has become an issue.\n\nNode processes are started using the `create_pids_for_nodes/2` function described in much detail above. The list of process IDs is drop to the floor, there is no need to pass this list back to the flow editor or any other component within Erlang-Red. Instead the flow editor is sent a JSON string with a `rev` value. This `rev` value has meaning in Node-RED but has yet gained the same status in Erlang-Red.\n\nScenario: **Inject node button is clicked**\n\nThis scenario describes how messages pass through flow processes. Erlang-Red has two types of messages, Erlang-Red messages that are represented by map instances containing external data and Erlang process messages that inform processes of events that have occurred. The Erlang messages are typed with semantic Erlang-Red meaning:\n\n- `{incoming, Msg}` when a node process receives this Erlang message it represents an incoming message containing a map instance (i.e., `Msg`) upon which the node functionality is to act. Once it has completed, it passes it results to all its downstream connected nodes as another `{incoming, Msg2}` message. It computes the process IDs of those nodes and sends them all their copy of the same message. Messages are unique and immutable, ideal data structures for Erlang.\n\n- `{outgoing, Msg}` an outgoing message is, in fact, very rare, in fact, only the inject node handles it. This is because it tells a node to *generate* an incoming message for its connected nodes. It represents the start of a flow execution. The inject node, upon receiving an outgoing message will add its details to the Msg instance and send `{ incoming, Msg2 }` messages to all its connected nods.\n\nThese the two main Erlang-Red message types. There are specific message types for specific inter-node-process communication (these are defined in the ered_node behaviour). Most Erlang messages are sent either via `gen_server:cast` or `gen_server:info`, that is, *off the clock* asynchronously. This can be done since state and data is stored in the `Msg` instance being passed around.\n\nWhen the inject button is triggered, a `POST` request is made to the inject button handler with the corresponding node ID. This is a enough-globally-unique ID that it uniquely identifies the inject node in the corresponding flow tab. The flow editor does a good job of ensuring correctness of uniqueness amongst node IDs, for example by updating IDs when nodes are copied and pasted within the flow editor.\n\n```mermaid\n%% Generated by the Flow2UML Node @ https://flowhub.org/flow2uml\n%% change direction to LR for Node-RED left-to-right UML\ngraph TB\n32aae51c7fd0833e@{ shape: \"braces\", label: \"Inject Button \\n &lt;Flow Editor&gt;\" } -- \"POST &lt;#47;inject#47;:NodeId&gt;\" --> f1265be5b1d05a2e@{ shape: \"rect\", label: \"Inject Route \\n &lt;ered_http_nodered_inject_node_button_handler.erl&gt;\" }\nf1265be5b1d05a2e@{ shape: \"rect\", label: \"Inject Route \\n &lt;ered_http_nodered_inject_node_button_handler.erl&gt;\" } == \"&lt;&lt;#34;OK#34;&gt;&gt;\" ==> 32aae51c7fd0833e@{ shape: \"braces\", label: \"Inject Button \\n &lt;Flow Editor&gt;\" }\nf1265be5b1d05a2e@{ shape: \"rect\", label: \"Inject Route \\n &lt;ered_http_nodered_inject_node_button_handler.erl&gt;\" } -- \"**#40;1#41;** call_to #40;Request#41;\" --> d741d819473b69a6@{ shape: \"rounded\", label: \"websocket_name_from_request#47;1 \\n &lt;ered_nodered_comm&gt;\" }\nf1265be5b1d05a2e@{ shape: \"rect\", label: \"Inject Route \\n &lt;ered_http_nodered_inject_node_button_handler.erl&gt;\" } -- \"**#40;2#41;** call_to #40;WsName, NodeId#41;\" --> 2d950f59605eb271@{ shape: \"rounded\", label: \"nodeid_to_pid#47;2 \\n &lt;ered_nodes&gt;\" }\nf1265be5b1d05a2e@{ shape: \"rect\", label: \"Inject Route \\n &lt;ered_http_nodered_inject_node_button_handler.erl&gt;\" } -- \"**#40;3#41;** call_to #40;WsName#41;\" --> 0bc9aeca9523da38@{ shape: \"rounded\", label: \"create_outgoing_msg#47;1 \\n &lt;ered_messages&gt;\" }\nf1265be5b1d05a2e@{ shape: \"rect\", label: \"Inject Route \\n &lt;ered_http_nodered_inject_node_button_handler.erl&gt;\" } -. \"**#40;4#41;** call_to #40;Pid, ErlangMsg#41;\" .-> c343cc778ca58428@{ shape: \"rounded\", label: \"cast#47;2 \\n &lt;gen_server&gt;\" }\nd741d819473b69a6@{ shape: \"rounded\", label: \"websocket_name_from_request#47;1 \\n &lt;ered_nodered_comm&gt;\" } == \"WsName\" ==> f1265be5b1d05a2e@{ shape: \"rect\", label: \"Inject Route \\n &lt;ered_http_nodered_inject_node_button_handler.erl&gt;\" }\n2d950f59605eb271@{ shape: \"rounded\", label: \"nodeid_to_pid#47;2 \\n &lt;ered_nodes&gt;\" } == \"Pid\" ==> f1265be5b1d05a2e@{ shape: \"rect\", label: \"Inject Route \\n &lt;ered_http_nodered_inject_node_button_handler.erl&gt;\" }\n0bc9aeca9523da38@{ shape: \"rounded\", label: \"create_outgoing_msg#47;1 \\n &lt;ered_messages&gt;\" } == \"ErlangMsg\" ==> f1265be5b1d05a2e@{ shape: \"rect\", label: \"Inject Route \\n &lt;ered_http_nodered_inject_node_button_handler.erl&gt;\" }\n```\n\n### Steps\n\n- **(1)** call to `websocket_name_from_request/1` to scope the request to the client\n- **(2)** call to `nodeid_to_pid/2` with the web-socket name and node ID, these uniquely identify the process within Erlang-Red that represents the inject node in the flow editor.\n- **(3)** call to `create_outgoing_msg/1` that creates the `{outgoing, Msg}` tuple that can be sent to the node process. The `Msg` map contains the web-socket name and a `_msgid` value that uniquely identifies the message throughout its lifecycle.\n- **(4)** call to `gen_server:cast/2` with the process ID of the inject node process and the Erlang outgoing message. \n\nWith that the message begins being propagated through the flow. The inject node adds its data to the message and then passes it on to all [nodes connected to it](https://github.com/gorenje/erlang-red/blob/075d2c2362b50d8bc5f602656c2740553413028e/src/nodes/ered_node_inject.erl#L150-L151). The inject node passes the modified message on via a `{incoming, Msg}` tuple to all node processes that represent the nodes connected to the inject node.\n\nOnce a message arrives at the end of a flow, it is dropped to the floor. There is no history of messages or replaying of messages or tracking of messages. Messages are very much ephemeral.\n\n## Conclusion\n\nThat was *how Node-RED flows are managed in Erlang by Erlang-Red*. It was longer than I had imagined but I hope the details aren't over powering. In writing this, I realised that there may be a certain *complexity creep* occurring in the Erlang architecture. My hopes are that this will be sufficient to provide a core for future nodes and their functionality, but time will only tell.\n\n## Erlang Code\n\n- [ered_startup.erl](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/ered_startup.erl)\n- [ered_node_erlsupervisor.erl](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/nodes/ered_node_erlsupervisor.erl)\n- [ered_node_erlmodule.erl](https://github.com/gorenje/erlang-red/blob/82075b02258dfb31a566213c168c890c4564dafd/src/nodes/ered_node_erlmodule.erl)\n- [ered_compute_engine.erl](https://github.com/gorenje/erlang-red/blob/075d2c2362b50d8bc5f602656c2740553413028e/src/servers/ered_compute_engine.erl)\n- [ered_node.erl](https://github.com/gorenje/erlang-red/blob/075d2c2362b50d8bc5f602656c2740553413028e/src/ered_node.erl)\n- [ered_http_nodered_inject_node_button_handler.erl](https://github.com/gorenje/erlang-red/blob/075d2c2362b50d8bc5f602656c2740553413028e/src/routes/ered_http_nodered_inject_node_button_handler.erl)\n- [ered_node_inject.erl](https://github.com/gorenje/erlang-red/blob/075d2c2362b50d8bc5f602656c2740553413028e/src/nodes/ered_node_inject.erl)\n","env":[]},{"id":"e55f8f8977682317","type":"group","z":"2d51a745ca17dc05","name":"ered_startup:create_pids_for_nodes/2","style":{"label":true},"nodes":["cd65242359acde9d","f7b57f5fa2684033","06d71e4d226a0b66","6f2a3728abcf40e8","4b74abd49857f467","993f43fc0fd83c72"],"x":493,"y":377,"w":659,"h":529},{"id":"cb362fe8a180a0e0","type":"group","z":"2d51a745ca17dc05","name":" ","style":{"label":true},"nodes":["7d549ef8f1abdf52","020edf6a03f5f1e1","771995a172e88ca0","5c278940932c7d45","7c90b2efc29436de","b610359d7e58d2d3"],"x":1670.25,"y":384,"w":734.5,"h":484.5},{"id":"cd65242359acde9d","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"e55f8f8977682317","name":"ered_startup.erl","shape":"doc","wirecfgs":[{"arrow":"-->","id":"f7b57f5fa2684033","name":"**(1)** call_to"},{"arrow":"-->","id":"993f43fc0fd83c72","name":"**(5)** call_to"},{"arrow":"-->","id":"6f2a3728abcf40e8","name":"**(3)** call_to"},{"arrow":"-->","id":"4b74abd49857f467","name":"**(4)** call_to"},{"arrow":"-->","id":"06d71e4d226a0b66","name":"**(2)** call_to"}],"x":599,"y":418,"wires":[["f7b57f5fa2684033","06d71e4d226a0b66","6f2a3728abcf40e8","4b74abd49857f467","993f43fc0fd83c72"]]},{"id":"f7b57f5fa2684033","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"e55f8f8977682317","name":"store_config_nodes/2","shape":"text","wirecfgs":[{"arrow":"-->","id":"deebe7665f77dc9a","name":"store_config_node"}],"x":986,"y":418,"wires":[["deebe7665f77dc9a"]]},{"id":"deebe7665f77dc9a","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"ered_config_store \\n <gen_server>","shape":"lin-cyl","wirecfgs":[],"x":1378,"y":418,"wires":[[]]},{"id":"06d71e4d226a0b66","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"e55f8f8977682317","name":"install_module_node_code/2","shape":"text","wirecfgs":[{"arrow":"-->","id":"b8a1bc7329daec62","name":"install/2"}],"x":1006,"y":538,"wires":[["b8a1bc7329daec62"]]},{"id":"647f1caf18f4e461","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"Outside World","shape":"braces","wirecfgs":[{"arrow":"-->","id":"cd65242359acde9d","name":"create_pids_for_nodes/2"}],"x":285,"y":418,"wires":[["cd65242359acde9d"]]},{"id":"b8a1bc7329daec62","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"ered_node_erlmodule","shape":"notch-rect","wirecfgs":[],"x":1388,"y":535,"wires":[[]]},{"id":"6f2a3728abcf40e8","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"e55f8f8977682317","name":"extract_supervisors/1","shape":"text","wirecfgs":[{"arrow":"==>","id":"cd65242359acde9d","name":"Supervisors"}],"x":986,"y":658,"wires":[["cd65242359acde9d"]]},{"id":"4b74abd49857f467","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"e55f8f8977682317","name":"supervisor_filter_nodes/5","shape":"text","wirecfgs":[{"arrow":"-->","id":"94123abe4da26501","name":"extract_nodes/2"}],"x":996,"y":778,"wires":[["94123abe4da26501"]]},{"id":"993f43fc0fd83c72","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"e55f8f8977682317","name":"create_pids_for_nodes/3","shape":"text","wirecfgs":[{"arrow":"--","id":"fd298b0409083e41","name":"defintion of"},{"arrow":"==>","id":"647f1caf18f4e461","name":"Pids"}],"x":1000,"y":865,"wires":[["647f1caf18f4e461"]]},{"id":"fd298b0409083e41","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"create_pids_for_nodes/3","shape":"text","wirecfgs":[{"arrow":"-->","id":"7d549ef8f1abdf52","name":"call_to"}],"x":1762.5,"y":247.5,"wires":[["7d549ef8f1abdf52"]]},{"id":"7d549ef8f1abdf52","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"cb362fe8a180a0e0","name":"spin_up_node/2","shape":"text","wirecfgs":[{"arrow":"==>","id":"fd298b0409083e41","name":"Pid"},{"arrow":"-->","id":"b610359d7e58d2d3","name":"**(5)** call_to"},{"arrow":"-->","id":"7c90b2efc29436de","name":"**(4)** call_to"},{"arrow":"-->","id":"771995a172e88ca0","name":"**(2)** call_to"},{"arrow":"-->","id":"5c278940932c7d45","name":"**(3)** call_to"},{"arrow":"-->","id":"020edf6a03f5f1e1","name":"**(1)** call_to"}],"x":1776.25,"y":425,"wires":[["fd298b0409083e41","020edf6a03f5f1e1","771995a172e88ca0","5c278940932c7d45","7c90b2efc29436de","b610359d7e58d2d3"]]},{"id":"020edf6a03f5f1e1","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"cb362fe8a180a0e0","name":"node_type_to_module/2","shape":"text","wirecfgs":[{"arrow":"==>","id":"7d549ef8f1abdf52","name":"Module"}],"x":2121.25,"y":425,"wires":[["7d549ef8f1abdf52"]]},{"id":"771995a172e88ca0","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"cb362fe8a180a0e0","name":"get_node_name/2","shape":"text","wirecfgs":[{"arrow":"==>","id":"7d549ef8f1abdf52","name":"GrpName"}],"x":2107.5,"y":542.5,"wires":[["7d549ef8f1abdf52"]]},{"id":"5c278940932c7d45","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"cb362fe8a180a0e0","name":"clear_pg_group(GrpName)","shape":"text","wirecfgs":[],"x":2140,"y":640,"wires":[[]]},{"id":"7c90b2efc29436de","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"cb362fe8a180a0e0","name":" Module:start/2","shape":"text","wirecfgs":[{"name":"Pid","id":"7d549ef8f1abdf52","arrow":"==>"},{"name":"call_to","id":"1587728bde29a151","arrow":"-->"}],"x":2101.25,"y":733.75,"wires":[["7d549ef8f1abdf52","1587728bde29a151"]]},{"id":"b610359d7e58d2d3","type":"mermaid-flowchart","z":"2d51a745ca17dc05","g":"cb362fe8a180a0e0","name":"gen_server:call(Pid, {registered, WsName, Pid}),","shape":"text","wirecfgs":[],"x":2198.75,"y":827.5,"wires":[[]]},{"id":"94123abe4da26501","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"Supervisor Module","shape":"notch-rect","wirecfgs":[],"x":1386,"y":777,"wires":[[]]},{"id":"374844f0a340e840","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"Deploy Route \\n <ered_http_nodered_flow_deploy_handler>","shape":"rounded","wirecfgs":[{"name":"<<{\"rev\":\"fed00d06\"}>>","id":"9b62183f75d29ea6","arrow":"==>"},{"name":"NodeDefinitions - List of Maps ","id":"01041555183d1b0b","arrow":"-->"}],"x":2962.178680419922,"y":436.9286003112793,"wires":[["01041555183d1b0b","9b62183f75d29ea6"]]},{"id":"9b62183f75d29ea6","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"Deploy \\n <Flow Editor>","shape":"braces","wirecfgs":[{"arrow":"-->","id":"374844f0a340e840","name":"JSON string"}],"x":2962.178680419922,"y":266.60716980695724,"wires":[["374844f0a340e840"]]},{"id":"15346d38f116f3ac","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"Startup \\n <ered_startup.erl>","shape":"rect","wirecfgs":[{"name":"ProcessIDs","id":"01041555183d1b0b","arrow":"==>"}],"x":2939.3213653564453,"y":772.7143688201904,"wires":[["01041555183d1b0b"]]},{"id":"01041555183d1b0b","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"Compute Engine \\n <ered_compute_engine.erl>","shape":"rounded","wirecfgs":[{"name":"Pid ! { stop }","id":"8e9bfb43fbc19e6c","arrow":"-.->"},{"name":"<<{\"rev\":\"fed00d06\"}>>","id":"374844f0a340e840","arrow":"==>"},{"name":"create_pids_for_nodes/2","id":"15346d38f116f3ac","arrow":"-->"}],"x":2962.178680419922,"y":607.2500308156013,"wires":[["374844f0a340e840","15346d38f116f3ac","8e9bfb43fbc19e6c"]]},{"id":"1587728bde29a151","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"spin_up_and_link_node/2","shape":"text","wirecfgs":[],"x":2585.7140731811523,"y":729.2857294082642,"wires":[[]]},{"id":"8e9bfb43fbc19e6c","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"Node Process","shape":"rect","wirecfgs":[],"x":3326,"y":685,"wires":[[]]},{"id":"32aae51c7fd0833e","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"Inject Button \\n <Flow Editor>","shape":"braces","wirecfgs":[{"name":"POST </inject/:NodeId>","id":"f1265be5b1d05a2e","arrow":"-->"}],"x":3678,"y":175,"wires":[["f1265be5b1d05a2e"]]},{"id":"f1265be5b1d05a2e","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"Inject Route \\n <ered_http_nodered_inject_node_button_handler.erl>","shape":"rect","wirecfgs":[{"name":"**(1)** call_to (Request)","id":"d741d819473b69a6","arrow":"-->"},{"name":"**(4)** call_to (Pid, ErlangMsg)","id":"c343cc778ca58428","arrow":"-.->"},{"name":"<<\"OK\">>","id":"32aae51c7fd0833e","arrow":"==>"},{"name":"**(2)** call_to (WsName, NodeId)","id":"2d950f59605eb271","arrow":"-->"},{"name":"**(3)** call_to (WsName)","id":"0bc9aeca9523da38","arrow":"-->"}],"x":3686,"y":385,"wires":[["32aae51c7fd0833e","d741d819473b69a6","2d950f59605eb271","0bc9aeca9523da38","c343cc778ca58428"]]},{"id":"d741d819473b69a6","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"websocket_name_from_request/1 \\n <ered_nodered_comm>","shape":"rounded","wirecfgs":[{"name":"WsName","id":"f1265be5b1d05a2e","arrow":"==>"}],"x":4130,"y":626,"wires":[["f1265be5b1d05a2e"]]},{"id":"2d950f59605eb271","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"nodeid_to_pid/2 \\n <ered_nodes>","shape":"rounded","wirecfgs":[{"name":"Pid","id":"f1265be5b1d05a2e","arrow":"==>"}],"x":4070,"y":723.3333333333334,"wires":[["f1265be5b1d05a2e"]]},{"id":"0bc9aeca9523da38","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"create_outgoing_msg/1 \\n <ered_messages>","shape":"rounded","wirecfgs":[{"name":"ErlangMsg","id":"f1265be5b1d05a2e","arrow":"==>"}],"x":4100,"y":820.6666666666667,"wires":[["f1265be5b1d05a2e"]]},{"id":"c343cc778ca58428","type":"mermaid-flowchart","z":"2d51a745ca17dc05","name":"cast/2 \\n <gen_server>","shape":"rounded","wirecfgs":[],"x":4070,"y":918,"wires":[[]]}]