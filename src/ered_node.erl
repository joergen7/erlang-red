-module(ered_node).

-behaviour(gen_server).

-export([
    start/2,
    init/1,
    handle_call/3,
    handle_cast/2,
    handle_info/2,
    code_change/3,
    terminate/2
]).

%%
%% the basis for every node type and each node type will become one or more
%% processes.
%%

%%
%% Behaviour definition
-callback start(NodeDef :: map(), WsName :: atom()) ->
    {ok, Pid :: pid()}.

-callback handle_msg(Msg :: tuple(), NodeDef :: map()) ->
    {unhandled, NodeDef2 :: map()}
    | {handled, NodeDef2 :: map(), Msg2 :: map()}
    | {handled, NodeDef2 :: map(), dont_send_complete_msg}.

-callback handle_event(Event :: tuple(), NodeDef :: map()) ->
    NodeDef2 :: map().

%%
%%
-import(ered_nodes, [
    this_should_not_happen/2
]).

-import(ered_nodered_comm, [
    unsupported/3,
    ws_from/1
]).

-import(ered_message_exchange, [
    post_completed/2
]).

-import(ered_startup, [
    add_counters/2,
    bump_counter/2
]).

%%
%% Register the NodePid with the pg module. This avoids filling the atom
%% table with unnecessary entries.
start(NodeDef, Module) ->
    {ok, NodePid} = maps:find('_node_pid_', NodeDef),
    {ok, Pid} = gen_server:start(?MODULE, {Module, NodeDef}, []),
    pg:join(NodePid, Pid),
    {ok, Pid}.

init({Module, NodeDef}) ->
    {ok, {Module, NodeDef}}.

%%
%% Sync calls to the node.

%% Filter nodes is a call to the supervisor to remove all the nodes from the
%% list for which it is responsible, It then stops and starts these nodes
%% as required.
handle_call({being_supervised, _WsName} = Msg, _From, {Module, NodeDef}) ->
    NodeDef2 = Module:handle_event(Msg, NodeDef#{'_being_supervised' => true}),
    {reply, ok, {Module, NodeDef2}};
handle_call({registered, _WsName, _Pid} = Msg, _From, {Module, NodeDef}) ->
    NodeDef2 = Module:handle_event(Msg, NodeDef),
    {reply, NodeDef2, {Module, NodeDef2}};
handle_call(Msg, _From, {Module, NodeDef}) ->
    io:format("Unknown call to node ~p: ~p~n", [self(), Msg]),
    {reply, NodeDef, {Module, NodeDef}}.

%%
%% ---------------------------------- Handle Cast -----------------------
%%

%%
%% Inter-node communication, messages that pass from one node to other nodes.

%% completed msg are posted by the post_completed call which called here
%% also! Endless loops are prevented by complete nodes (which receive these
%% messages) marking messages with their ids.
handle_cast({completed_msg = MsgType, FromNodeDef, Msg}, {Module, NodeDef}) ->
    Results = Module:handle_msg(
        {MsgType, FromNodeDef, Msg},
        bump_counter(MsgType, NodeDef)
    ),
    handle_msg_responder(MsgType, Msg, Module, Results, post_completed);
%% exception raised by some other node and caught be a catch node - if
%% it exists.
handle_cast({exception = MsgType, From, Msg, ErrMsg}, {Module, NodeDef}) ->
    Results = Module:handle_msg(
        {MsgType, From, Msg, ErrMsg},
        bump_counter(MsgType, NodeDef)
    ),
    handle_msg_responder(MsgType, Msg, Module, Results, post_completed);
%%
%% This is for setting the active flag on the NodeDef - this is used for
%% the debug node.
handle_cast({disable, _WsName}, {Module, NodeDef}) ->
    {noreply, {Module, NodeDef#{<<"active">> => false}}};
handle_cast({enable, _WsName}, {Module, NodeDef}) ->
    {noreply, {Module, NodeDef#{<<"active">> => true}}};
%% outgoing messages are those generated by nodes such inject or http-in
%% these are messages sources and pass these messages off.
handle_cast({outgoing = MsgType, Msg}, {Module, NodeDef}) ->
    Results = Module:handle_msg({MsgType, Msg}, bump_counter(MsgType, NodeDef)),
    handle_msg_responder(MsgType, Msg, Module, Results, dont_post_completed);
%% ws_event is a websocket event that is passed to an assert node.
handle_cast({ws_event = MsgType, Details}, {Module, NodeDef}) ->
    Results = Module:handle_msg(
        {MsgType, Details},
        bump_counter(MsgType, NodeDef)
    ),
    handle_msg_responder(
        MsgType, Details, Module, Results, dont_post_completed
    );
%% incoming message for node, pass this off to the message tracer service
handle_cast({incoming = MsgType, Msg}, {Module, NodeDef}) ->
    ered_msgtracer_manager:node_received_msg(NodeDef, self(), Msg),
    Results = Module:handle_msg({MsgType, Msg}, bump_counter(MsgType, NodeDef)),
    handle_msg_responder(MsgType, Msg, Module, Results, post_completed);
%% This function signature can match the following messages:
%%    - {link_return, Msg}
%%    - {mqtt_incoming, Msg}
%%    - {delay_push_out, Msg}
%%    - {mqtt_not_sent, Msg}
%%    - {func_completed_with, Msg}
%% These post_completed messages, hence they differ from the more general
%% use case.
handle_cast({MsgType, Msg}, {Module, NodeDef}) ->
    Results = Module:handle_msg({MsgType, Msg}, bump_counter(MsgType, NodeDef)),
    handle_msg_responder(MsgType, Msg, Module, Results, post_completed);
handle_cast(Msg, {Module, NodeDef}) ->
    unsupported(NodeDef, Msg, <<"Unsupported Msg Received">>),
    {noreply, {Module, NodeDef}}.
%%
%% ---------------------------------- Handle Info -----------------------
%%

%% Events generate by the system.
handle_info({reload}, {Module, NodeDef}) ->
    {ok, NodePid} = maps:find('_node_pid_', NodeDef),
    NodeDef2 = Module:handle_event(deploy, add_counters(NodeDef, NodePid)),
    {noreply, {Module, NodeDef2}};
handle_info({mqtt_disconnected, ReasonCode, Properties}, {Module, NodeDef}) ->
    NodeDef2 = Module:handle_event(
        {mqtt_disconnected, ReasonCode, Properties}, NodeDef
    ),
    {noreply, {Module, NodeDef2}};
handle_info({deploy, NewNodeDef}, {Module, NodeDef}) ->
    {ok, NodePid} = maps:find('_node_pid_', NodeDef),
    NodeDef2 = Module:handle_event(deploy, add_counters(NewNodeDef, NodePid)),
    {noreply, {Module, NodeDef2}};
%%
%% If any node decides to monitor other processes, then it will generate
%% these messages. Pass them on
handle_info({'DOWN', _, _, _, _} = Event, {Module, NodeDef}) ->
    NodeDef2 = Module:handle_event(Event, NodeDef),
    {noreply, {Module, NodeDef2}};
handle_info({'EXIT', _From, _Reason} = Event, {Module, NodeDef}) ->
    NodeDef2 = Module:handle_event(Event, NodeDef),
    %% TODO revisit this return value - there could be a case made for this
    %% TODO return value being defined by the node itself.
    {stop, normal, {Module, NodeDef2}};
%%
%% timeout event is generated by a erlang:start_timer(...) that can
%% be useful for auot reconnecting to services that should be available
handle_info({timeout, _TimerRef, Msg}, {Module, NodeDef}) ->
    NodeDef2 = Module:handle_event(Msg, NodeDef),
    {noreply, {Module, NodeDef2}};
handle_info({supervisor_node, Tuple}, {Module, NodeDef}) ->
    NodeDef2 = Module:handle_event(Tuple, NodeDef),
    {noreply, {Module, NodeDef2}};
%%
%% Tcp communication, can either be generated by the tcp listener to the
%% tcp connector and could be destined for either the tcp-in or tcp-out or
%% tcp-request node.
handle_info({tcp_comm, Tuple}, {Module, NodeDef}) ->
    NodeDef2 = Module:handle_event(Tuple, NodeDef),
    {noreply, {Module, NodeDef2}};
%%
%% Generated by the function node when a function executes code
handle_info({function_eval_result = MsgType, Msg, _O} = Evt, {Module, NodeDef}) ->
    Results = Module:handle_msg(Evt, bump_counter(MsgType, NodeDef)),
    handle_msg_responder(MsgType, Msg, Module, Results, post_completed);
%%
%% Now this is bad. Stopping is really the last thing that should happen.
handle_info({stop, WsName}, {Module, NodeDef}) ->
    Module:handle_event({stop, WsName}, NodeDef),
    {stop, normal, {Module, NodeDef}};
handle_info(Event, {Module, NodeDef}) ->
    io:format(
        "Node ~p, ~p Received unsupported event {{{ ~p }}}~n",
        [self(), maps:get(<<"type">>, NodeDef), Event]
    ),
    {noreply, {Module, NodeDef}}.

%%
%% ------------------------ Termination
%%

%%
%%
code_change(_OldVersion, State, _Extra) ->
    {ok, State}.

terminate(normal, _State) ->
    ok;
terminate(fake_crash, _State) ->
    % used by the supervisor test to demonstrate a non-normal exit.
    ok;
terminate(Event, {Module, NodeDef} = State) ->
    case Module:handle_event({gen_server_terminated, Event}, NodeDef) of
        handled ->
            ignore;
        _ ->
            io:format(
                "Node ~p: Non-normal Termination: '~p' State: {{{ ~p }}}~n",
                [self(), Event, State]
            )
    end,
    ok.

%%
%% ------------------------ Helpers
%%

%%
%%
handle_msg_responder(MsgType, Msg, Module, Results, post_completed) ->
    case Results of
        {handled, NodeDef2, dont_send_complete_msg} ->
            {noreply, {Module, NodeDef2}};
        {handled, NodeDef2, Msg2} ->
            post_completed(NodeDef2, Msg2),
            {noreply, {Module, NodeDef2}};
        {unhandled, NodeDef2} ->
            bad_routing(NodeDef2, MsgType, Msg),
            {noreply, {Module, NodeDef2}}
    end;
handle_msg_responder(MsgType, Msg, Module, Results, dont_post_completed) ->
    case Results of
        {handled, NodeDef2, _Msg2} ->
            {noreply, {Module, NodeDef2}};
        {unhandled, NodeDef2} ->
            bad_routing(NodeDef2, MsgType, Msg),
            {noreply, {Module, NodeDef2}}
    end.

%%
%%

bad_routing(NodeDef, Type, Msg) ->
    this_should_not_happen(
        NodeDef,
        io_lib:format(
            "Unhandled message type [~p] ~n~nNode: [~p, ~p]~n~nMsg: ~p\n",
            [
                Type,
                maps:get(<<"id">>, NodeDef),
                maps:get(<<"type">>, NodeDef),
                Msg
            ]
        )
    ).
